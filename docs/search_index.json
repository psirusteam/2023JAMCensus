[["index.html", "Material del taller", " Material del taller En el siguiente enlace encontrarás las rutinas R desarrolladas para el taller.. Descargar "],["instalación-de-bibliotecas-y-software-necesario-para-modelos-de-censo-con-enfoque-bayesiano.html", "Chapter 1 Instalación de bibliotecas y software necesario para modelos de censo con enfoque bayesiano ", " Chapter 1 Instalación de bibliotecas y software necesario para modelos de censo con enfoque bayesiano "],["paso-1-instalación-del-software.html", "1.1 Paso 1: Instalación del software", " 1.1 Paso 1: Instalación del software A continuación se muestra una lista del software necesario para el correcto desarrollo de la formación. Se recomienda instalar estos paquetes antes de comenzar con el desarrollo práctico. Descargue e instale Rbase (https://cran.r-project.org/bin/windows/base/) Descargue e instale Rtools (https://cran.r-project.org/bin/windows/Rtools/) Descargue e instale Rstudio (https://posit.co/download/rstudio-desktop/) Descargue e instale Quarto (https://quarto.org/docs/get-started/) Descargue e instale Anaconda (https://www.anaconda.com/products/individual) Descargue e instale Google Cloud (https://cloud.google.com/sdk/docs/install?hl=es-419) "],["paso-2-instalar-las-siguientes-bibliotecas-en-r..html", "1.2 Paso 2: Instalar las siguientes bibliotecas en R.", " 1.2 Paso 2: Instalar las siguientes bibliotecas en R. 1.2.1 Visualización y manipulación de datos: tidyverse : una colección de paquetes para manipulación y visualización de datos. magrittr : proporciona un %&gt;%operador de canalización para hacer que el código sea más legible. scales : herramientas para escalar visualizaciones, como ajustar las rupturas de eje. sf : Para trabajar con datos espaciales y mapas. tmap : Crea mapas temáticos y superposiciones. 1.2.2 Modelos estadísticos: lme4: Se adapta a modelos lineales y lineales generalizados de efectos mixtos. rstanarm: Se adapta a modelos bayesianos utilizando Stan para diversas tareas estadísticas. 1.2.3 Analisis de encuestas: srvyr: Herramientas para trabajar con datos de encuestas junto con el paquete dplyr. survey: Para analizar datos de encuestas complejos. 1.2.4 Manipulación y Transformación de Datos: dplyr: Herramientas de manipulación de datos. tidyr: Herramientas para remodelar y ordenar datos. reshape2: Reordenar de marcos de datos.. 1.2.5 Análisis Bayesiano: bayesplot: Visualización de modelos bayesianos. posterior: Herramientas para trabajar con distribuciones posteriores. rstan: Interfaz R para Stan, una plataforma para modelado bayesiano. 1.2.6 Geospatial Analysis: rgee: Interfaz para Google Earth Engine. trafo: Herramientas para transformar datos espaciales. maptools: Herramientas de lectura y manipulación de datos geográficos. usmap: Mapas de Estados Unidos. 1.2.7 Misceláneas: sampling: Herramientas para muestreo de encuestas. haven: Para leer y escribir archivos SPSS, Stata y SAS. RColorBrewer: Proporciona paletas de colores. kableExtra: Mejora la representación de tablas en R Markdown. formatR: Herramientas de formato para código R. printr: Impresión personalizada de marcos de datos y tablas. remotes: Herramientas para el desarrollo e instalación de paquetes. latex2exp: Convierte código LaTeX en expresiones. Para instalar cada paquete, use el comando install.packages(\"package_name\"). install.packages(&quot;patchwork&quot;) install.packages(&quot;lme4&quot;) install.packages(&quot;tidyverse&quot;) install.packages(&quot;rstanarm&quot;) install.packages(&quot;magrittr&quot;) install.packages(&quot;reticulate&quot;) install.packages(&quot;rgee&quot;) install.packages(&quot;sf&quot;) install.packages(&quot;tmap&quot;) install.packages(&quot;trafo&quot;) install.packages(&quot;scales&quot;) install.packages(&quot;srvyr&quot;) install.packages(&quot;survey&quot;) install.packages(&quot;haven&quot;) install.packages(&quot;sampling&quot;) install.packages(&quot;RColorBrewer&quot;) install.packages(&quot;maptools&quot;) install.packages(&quot;data.table&quot;) install.packages(&quot;forcats&quot;) install.packages(&quot;tidyr&quot;) install.packages(&quot;reshape2&quot;) install.packages(&quot;bayesplot&quot;) install.packages(&quot;posterior&quot;) install.packages(&quot;gridExtra&quot;) install.packages(&quot;ggalt&quot;) install.packages(&quot;usmap&quot;) install.packages(&quot;kableExtra&quot;) install.packages(&quot;formatR&quot;) install.packages(&quot;printr&quot;) install.packages(&quot;remotes&quot;) install.packages(&quot;latex2exp&quot;) install.packages(&quot;gtsummary&quot;) 1.2.8 Guía paso a paso para instalar rstan Siga estos pasos para instalar el paquete rstan: Instale Rtools (si usa Windows): Descargue e instale Rtools. instalar StanHeaders: Abrir R o RStudio. Ejecute el comando: install.packages(\"StanHeaders\", repos = c(\"https://mc-stan.org/r-packages/\", getOption(\"repos\"))). Instalar rstan: Ejecute el comando: install.packages(\"rstan\", repos=c(\"https://mc-stan.org/r-packages/\", getOption(\"repos\"))). Verifique la instalación de la librería Cargue la librería usando: library(rstan). Validación de la instalación: Ejecute un modelo simple para asegurarse de que rstan funcione correctamente. Puede utilizar el código de ejemplo proporcionado en la documentación. Recuerde seguir estos pasos cuidadosamente para garantizar una instalación exitosa rstan y sus dependencias. "],["paso-3-validación-de-la-instalación-garantizar-una-instalación-adecuada-de-rstan.html", "1.3 Paso 3: Validación de la instalación: garantizar una instalación adecuada de rstan", " 1.3 Paso 3: Validación de la instalación: garantizar una instalación adecuada de rstan En esta sección, validamos la instalación correcta de rstan ejecutando un modelo bayesiano simple. Cargamos los paquetes necesarios, incluidos rstan, posterior y bayesplot. Luego definimos un modelo Stan básico usando el código Stan proporcionado. Ajustamos este modelo usando stan() con una pequeña cantidad de iteraciones (iter = 10) para verificar rápidamente la instalación. A continuación, demostramos cómo ajustar aún más el modelo (fit2) con más iteraciones (iter = 10000) para mostrar cómo realizar un análisis más completo. El resumen del modelo ajustado se imprime utilizando la función summary(). Asegúrese de evaluar este código en un entorno R después de instalar los paquetes necesarios para verificar que rstan se haya instalado correctamente y funcione como se esperaba. library(rstan) library(posterior) library(bayesplot) # Example Stan code stan_code &lt;- &quot; parameters { real y[2]; } model { y[1] ~ normal(0, 1); y[2] ~ double_exponential(0, 2); } &quot; # Fit the model fit1 &lt;- stan(model_code = stan_code, iter = 10, verbose = FALSE) # Print the fit1 object print(fit1) # Further fitting and summarizing fit2 &lt;- stan(fit = fit1, iter = 10000, verbose = FALSE) summary(fit2)$summary "],["paso-4-crear-una-cuenta-de-google-earth-engine.html", "1.4 Paso 4: Crear una cuenta de Google Earth Engine:", " 1.4 Paso 4: Crear una cuenta de Google Earth Engine: https://developers.google.com/earth-engine/datasets/ Después de crear exitosamente su cuenta, es importante seguir estos pasos para asegurarse de que todo esté configurado correctamente: Acceda al enlace proporcionado: https://developers.google.com/earth-engine/datasets/catalog/WHRC_biomass_tropical. Desplácese hasta el final de la página y localice el código que se muestra en la imagen a continuación: Haga clic en la opción Open in Code Editor, que abrirá una nueva pestaña del navegador. Siga las instrucciones proporcionadas hasta lograr el resultado que se muestra en la imagen a continuación: En la pestaña anterior, busque y haga clic en el botón Run para obtener el resultado que se muestra en la imagen a continuación: Nota: Repita el proceso según sea necesario para asegurarse de lograr el resultado deseado. "],["estandarización-y-validación-de-variables-de-datos-censales-disponibles.html", "Chapter 2 Estandarización y validación de variables de datos censales disponibles", " Chapter 2 Estandarización y validación de variables de datos censales disponibles En el siguiente conjunto de códigos, se llevan a cabo una serie de procesos para la limpieza y preparación de datos. Estos pasos incluyen eliminar objetos del espacio de trabajo, cargar las librerías necesarias, leer datos del censo, asignar valores faltantes según ciertas condiciones y calcular estadísticas descriptivas para variables numéricas y de caracteres. Además, se realizan ajustes a las variables de caracteres para garantizar una longitud constante. Los resultados finales se resumen en una estructura de datos y se guardan en archivos para su posterior análisis y referencia. library(tidyverse) library(data.table) library(openxlsx) library(DataExplorer) library(magrittr) library(RColorBrewer) select&lt;- dplyr::select cat(&quot;\\f&quot;) censo &lt;- readRDS(&quot;Recursos/01_Input_Validation/Data/Data_census_V2023-06-12.rds&quot;) %&gt;% select(-geometry) %&gt;% as.data.frame() # Creating a summary data frame for column names and their respective data types. resumen &lt;- data.frame(Nombre_Columna = names(censo)) resumen %&lt;&gt;% mutate(tipo = map_chr(Nombre_Columna, function(x) class(censo[[x]]))) resumen &lt;- readRDS(&quot;Recursos/01_Input_Validation/RecurseBooks/resumen1.rds&quot;) tba(head(resumen,10)) Nombre_Columna tipo un_ID integer PROV_ID character CANT_ID character DIST_ID character UGM_ID character LLAVEV character RESUL_ENTREVISTA_VIV integer TIPO_VIVIENDA_PRECENSO character V01_TIPO_VIVIENDA integer V02_OCUPACION_VIVIENDA integer "],["asignación-de-valores-faltantes-a-la-variable-h01a_total_personas.html", "2.1 Asignación de valores faltantes a la variable H01A_TOTAL_PERSONAS", " 2.1 Asignación de valores faltantes a la variable H01A_TOTAL_PERSONAS En esta sección se realizan acciones relacionadas con la variable H01A_TOTAL_PERSONAS. Los valores faltantes (NA) se asignan a esta variable según condiciones específicas, que incluyen: Viviendas que no fueron visitadas (categoría 9). Viviendas que rechazaron la visita o se encuentran pendientes (clasificación 2). Viviendas con otros motivos (categoría 8). A continuación se realiza un recuento de casos antes y después de la asignación de valores faltantes. La función mutar se utiliza para crear una nueva columna temporal H01A_TOTAL_PERSONAS_temp en la que se asignan valores NA de acuerdo con las condiciones especificadas. Luego, la información se agrupa por la variable V02_OCUPACION_VIVIENDA y se calcula el número de valores faltantes (NAs) antes y después de la asignación, junto con el recuento total de valores faltantes después de la asignación. Posteriormente, se realiza otra asignación de valores faltantes directamente a la variable H01A_TOTAL_PERSONAS dentro del conjunto de datos censo. Esto se hace siguiendo las mismas condiciones mencionadas anteriormente. censo %&gt;% mutate( H01A_TOTAL_PERSONAS_temp = case_when( V02_OCUPACION_VIVIENDA == &quot;9&quot; ~ NA_real_, V02_OCUPACION_VIVIENDA == &quot;2&quot; ~ NA_real_, V02_OCUPACION_VIVIENDA == &quot;8&quot; ~ NA_real_, TRUE ~ H01A_TOTAL_PERSONAS ) ) %&gt;% group_by(V02_OCUPACION_VIVIENDA) %&gt;% summarise(nas_antes = sum(is.na(H01A_TOTAL_PERSONAS)), nas_despues = sum(is.na(H01A_TOTAL_PERSONAS_temp))) %&gt;% mutate(total_nas_despues = sum(nas_despues)) ## Assignment of Missing Values censo %&lt;&gt;% mutate( H01A_TOTAL_PERSONAS = case_when( V02_OCUPACION_VIVIENDA == &quot;9&quot; ~ NA_real_, V02_OCUPACION_VIVIENDA == &quot;2&quot; ~ NA_real_, V02_OCUPACION_VIVIENDA == &quot;8&quot; ~ NA_real_, TRUE ~ H01A_TOTAL_PERSONAS ) ) "],["valores-descriptivos-de-los-datos-censos.html", "2.2 Valores Descriptivos de los Datos Censos", " 2.2 Valores Descriptivos de los Datos Censos Variables numéricas En esta sección, se calculan varias estadísticas descriptivas para las variables numéricas dentro del conjunto de datos del censo. Estas estadísticas proporcionan información sobre la distribución y las características de los datos numéricos. max_values: Los valores máximos de variables numéricas y enteras se calculan utilizando las funciones summarise y pivot_longer. El resultado es una tabla que enumera los valores máximos para cada variable. min_values: De manera similar, los valores mínimos de variables numéricas y enteras se calculan y organizan en un formato de tabla. media_values: los valores medios (promedio) de variables numéricas y enteras se calculan y presentan en forma de tabla. mediana_values: Los valores medianos de variables numéricas y enteras se determinan y muestran como una tabla. SD_values: las desviaciones estándar (SD) de variables numéricas y enteras se calculan y organizan en una estructura de tabla. nas_values: el número de valores faltantes (NA) para cada variable numérica y entera se cuenta y se presenta en formato tabular. max_values &lt;- censo %&gt;% summarise(across(where(is.numeric) | where(is.integer), max)) %&gt;% pivot_longer(everything(), names_to = &quot;Nombre_Columna&quot;, values_to = &quot;Valor_Maximo&quot;) min_values &lt;- censo %&gt;% summarise(across(where(is.numeric) | where(is.integer), min)) %&gt;% pivot_longer(everything(), names_to = &quot;Nombre_Columna&quot;, values_to = &quot;Valor_Minimo&quot;) media_values &lt;- censo %&gt;% summarise(across(where(is.numeric) | where(is.integer), mean)) %&gt;% pivot_longer(everything(), names_to = &quot;Nombre_Columna&quot;, values_to = &quot;Valor_Media&quot;) mediana_values &lt;- censo %&gt;% summarise(across(where(is.numeric) | where(is.integer), median)) %&gt;% pivot_longer(everything(), names_to = &quot;Nombre_Columna&quot;, values_to = &quot;Valor_Mediana&quot;) SD_values &lt;- censo %&gt;% summarise(across(where(is.numeric) | where(is.integer), sd)) %&gt;% pivot_longer(everything(), names_to = &quot;Nombre_Columna&quot;, values_to = &quot;Valor_sd&quot;) nas_values &lt;- censo %&gt;% summarise(across(where(is.numeric) | where(is.integer), function(x)sum(is.na(x)))) %&gt;% pivot_longer(everything(), names_to = &quot;Nombre_Columna&quot;, values_to = &quot;Num_nas&quot;) Variables de caracteres Para las variables de caracteres dentro del conjunto de datos del censo, se generan estadísticas descriptivas específicas: max_char: esta tabla contiene las longitudes máximas de las variables de caracteres. Calcula el número máximo de caracteres dentro de cada variable de carácter. min_char: similar a max_char, esta tabla proporciona las longitudes mínimas de las variables de caracteres. nas_values_char: esta tabla muestra los recuentos de valores faltantes (NA) para cada variable de carácter. max_char &lt;- censo %&gt;% summarise(across(where(is.character), function(x)max(nchar(x)))) %&gt;% pivot_longer(everything(), names_to = &quot;Nombre_Columna&quot;, values_to = &quot;leng_max&quot;) min_char &lt;- censo %&gt;% summarise(across(where(is.character), function(x)min(nchar(x)))) %&gt;% pivot_longer(everything(), names_to = &quot;Nombre_Columna&quot;, values_to = &quot;leng_min&quot;) nas_values_char &lt;- censo %&gt;% summarise(across(where(is.character) , function(x)sum(is.na(x)))) %&gt;% pivot_longer(everything(), names_to = &quot;Nombre_Columna&quot;, values_to = &quot;Num_nas_char&quot;) "],["organización-de-resultados-en-una-base-de-datos.html", "2.3 Organización de resultados en una base de datos", " 2.3 Organización de resultados en una base de datos En esta sección, las estadísticas descriptivas recopiladas se organizan y combinan en una base de datos resumida integral denominada resumen2. Para lograr esto, se utiliza la función reducir con una lista de tablas que contienen las distintas estadísticas. Las tablas incluyen estadísticas relacionadas con variables de caracteres (nas_values_char, min_char, max_char), variables numéricas (nas_values, SD_values, mediana_values, media_values, min_values, max_values), y una tabla que contiene información sobre nombres y tipos de variables (“resumen”). La función full_join se aplica de forma iterativa utilizando reduce para combinar todas estas tablas. El parámetro by especifica que la unión debe realizarse en función de la variable Nombre_Columna, asegurando que las estadísticas de cada variable coincidan y alineen correctamente. El resultado final es la base de datos resumen2, que proporciona una vista consolidada de estadísticas descriptivas para cada variable en el conjunto de datos del censo, incorporando información sobre NA, mínimos, máximos, desviaciones estándar, medianas, medias y más. resumen2 &lt;- reduce( list( nas_values_char, min_char, max_char, nas_values, SD_values, mediana_values, media_values, min_values, max_values ), full_join, by = join_by(Nombre_Columna) ) %&gt;% full_join(x = resumen, y = ., by = join_by(Nombre_Columna)) # save data openxlsx::write.xlsx(resumen2, file = &quot;Recursos/01_Input_Validation/Data/Estado_base.xlsx&quot;) openxlsx::openXL(&quot;Recursos/01_Input_Validation/Data/Estado_base.xlsx&quot;) Nombre_Columna tipo Num_nas_char leng_min leng_max Num_nas Valor_sd Valor_Mediana Valor_Media Valor_Minimo Valor_Maximo un_ID integer NA NA NA 0 503230.4746 871621 871621.0000 1 1743241 PROV_ID character 0 1 1 NA NA NA NA NA NA CANT_ID character 0 3 3 NA NA NA NA NA NA DIST_ID character 0 5 5 NA NA NA NA NA NA UGM_ID character 0 8 8 NA NA NA NA NA NA LLAVEV character 0 1 14 NA NA NA NA NA NA RESUL_ENTREVISTA_VIV integer NA NA NA 0 1.5899 1 2.2408 1 5 TIPO_VIVIENDA_PRECENSO character 0 1 22 NA NA NA NA NA NA V01_TIPO_VIVIENDA integer NA NA NA 0 4.6571 1 2.9378 1 15 V02_OCUPACION_VIVIENDA integer NA NA NA 0 2.8114 2 2.9311 1 9 "],["actualización-del-conjunto-de-datos-basada-en-los-resultados-del-informe.html", "2.4 Actualización del conjunto de datos basada en los resultados del informe", " 2.4 Actualización del conjunto de datos basada en los resultados del informe En esta parte del código, el conjunto de datos censo se actualiza en función de los resultados obtenidos del informe. Primero, se define el vector Nombre_Columna, que contiene los nombres de las columnas que se van a actualizar. A continuación, se define el vector Tipo_actualizar, que contiene las funciones de conversión de tipo que se aplicarán a cada columna correspondiente. Utilizando la función map2 del paquete purrr, se itera sobre cada par de elementos en Nombre_Columna y Tipo_actualizar, aplicando la respectiva función de conversión de tipo a cada columna en el conjunto de datos censo. Esto se logra utilizando la función &lt;&lt;- para actualizar los valores en el conjunto de datos original. Finalmente, se crea un nuevo conjunto de datos censo2 que solo contiene las columnas especificadas en Nombre_Columna. Esto garantiza que el conjunto de datos se actualice de acuerdo con los tipos de datos y las modificaciones realizadas en función de los resultados del informe. Nombre_Columna &lt;- c( &quot;un_ID&quot; , &quot;PROV_ID&quot; , &quot;CANT_ID&quot; , &quot;DIST_ID&quot; , &quot;UGM_ID&quot; , &quot;LLAVEV&quot; , &quot;RESUL_ENTREVISTA_VIV&quot; , &quot;TIPO_VIVIENDA_PRECENSO&quot; , &quot;V01_TIPO_VIVIENDA&quot; , &quot;V02_OCUPACION_VIVIENDA&quot; , &quot;H01A_TOTAL_PERSONAS&quot; , &quot;greenpoint&quot; , &quot;ugm_viviendas_totales_censo&quot; , &quot;ugm_viviendas_ocupadas_censo&quot; , &quot;ugm_viviendas_desocupadas_censo&quot; , &quot;ugm_peligrosidad&quot; , &quot;ugm_problema_de_acceso&quot; , &quot;ugm_riesgos_amenazas&quot; , &quot;ugm_cobertura_telecomunicaciones&quot; , &quot;asent&quot; , &quot;ppp_CRI_v2&quot; , &quot;elev&quot; , &quot;indig&quot; , &quot;aprot&quot; , &quot;dist_permisos_de_construccion_2011_2022&quot; , &quot;dist_poblacion_proyeccion_ajustada_2022&quot; , &quot;dist_poblacion_ccss_abril_2023&quot; , &quot;dist_matricula_educacion_primaria_2021&quot; , &quot;dist_codigo_urbanidad&quot; , &quot;GHS_BUILT_S_E2020_GLOBE_R2023A_5367_CRI&quot; , &quot;urban_coverfraction&quot; , &quot;crops_coverfraction&quot; , &quot;ebais_tt&quot; , &quot;escu_tt&quot; , &quot;igl_tt&quot; , &quot;prov_nl_mean&quot; , &quot;cant_nl_mean&quot; , &quot;dist_nl_mean&quot; , &quot;wpop_sum&quot; ) Tipo_actualizar &lt;- c( as.character, as.character, as.character, as.character, as.character, as.character, as.character, as.character, as.character, as.character, as.numeric, as.character, as.numeric, as.numeric, as.numeric, as.character, as.character, as.character, as.character, as.character, as.numeric, as.numeric, as.character, as.character, as.numeric, as.numeric, as.numeric, as.numeric, as.character, as.numeric, as.numeric, as.numeric, as.numeric, as.numeric, as.numeric, as.numeric, as.numeric, as.numeric, as.numeric) map2(Nombre_Columna, Tipo_actualizar, function(nom,tipo){ censo[[nom]] &lt;&lt;- tipo(censo[[nom]]) }) # Selecting columns specified in `Nombre_Columna` censo2 &lt;- censo %&gt;% select(all_of(Nombre_Columna)) "],["refinamiento-y-análisis-del-conjunto-de-datos.html", "2.5 Refinamiento y Análisis del Conjunto de Datos", " 2.5 Refinamiento y Análisis del Conjunto de Datos En esta sección, el conjunto de datos censo se refina aún más, y se realizan algunos análisis descriptivos en el conjunto de datos actualizado. Además, los resultados de estos análisis se guardan en el directorio especificado. Resumen de variables censo2 %&gt;% distinct(UGM_ID, wpop_sum) %&gt;% summarise(n = sum(wpop_sum)) %&gt;% tba() n 4653649 Conteo de ugm_viviendas_totales_censo == 0 censo2 %&gt;% distinct(UGM_ID, ugm_viviendas_totales_censo) %&gt;% mutate(categoria = cut(ugm_viviendas_totales_censo, breaks = c(-1:5, 10, 20, 50, max(ugm_viviendas_totales_censo) ))) %&gt;% group_by(categoria) %&gt;% tally() %&gt;% tba() categoria n (-1,0] 3744 (0,1] 1760 (1,2] 1441 (2,3] 1446 (3,4] 1412 (4,5] 1527 (5,10] 7317 (10,20] 11660 (20,50] 12516 (50,285] 5170 Comparación con el número de registros por UGM ugm_cero_viviendas &lt;- censo2 %&gt;% distinct(UGM_ID, ugm_viviendas_totales_censo) %&gt;% filter(ugm_viviendas_totales_censo == 0) cont_registros_ugm &lt;- censo2 %&gt;% group_by(UGM_ID) %&gt;% tally(name = &quot;Total_vivienda_ugm&quot;) inner_join(ugm_cero_viviendas, cont_registros_ugm) %&gt;% summarise(n_ugm = n(), min = min(Total_vivienda_ugm), max = max(Total_vivienda_ugm), mediana = median(Total_vivienda_ugm)) %&gt;% tba() n_ugm min max mediana 3744 1 207 12 Resumen de variables para una condición específica censo2 %&gt;% filter(V02_OCUPACION_VIVIENDA == &quot;8&quot;) %&gt;% summarise(n_viviendas = n(), min = min(H01A_TOTAL_PERSONAS), max = max(H01A_TOTAL_PERSONAS), mediana = median(H01A_TOTAL_PERSONAS)) %&gt;% tba() n_viviendas min max mediana 74871 0 0 0 "],["resumen-y-análisis-de-datos.html", "2.6 Resumen y Análisis de Datos", " 2.6 Resumen y Análisis de Datos En esta sección, estamos resumiendo y analizando los datos para obtener información clave. Calcularemos diferentes medidas para comprender las características de las variables. Creación de un resumen de los nombres de las columnas y sus tipos de datos resumen &lt;- data.frame(Nombre_Columna = names(censo2)) resumen %&lt;&gt;% mutate(tipo = map_chr(Nombre_Columna, function(x)class(censo2[[x]]))) Comprobación de variables de tipo carácter y aseguramiento de una longitud de carácter consistente tipo_char &lt;- resumen$Nombre_Columna[resumen$tipo == &quot;character&quot;] for(ii in tipo_char) { max_char &lt;- max(nchar(censo2[[ii]])) censo2[[ii]] &lt;- str_pad(string = censo2[[ii]], width = max_char, pad = &quot;0&quot;) } Resumen de variables de tipo carácter max_char &lt;- censo %&gt;% summarise(across(where(is.character), function(x) max(nchar(x)))) %&gt;% pivot_longer(everything(), names_to = &quot;Nombre_Columna&quot;, values_to = &quot;leng_max&quot;) min_char &lt;- censo %&gt;% summarise(across(where(is.character), function(x) min(nchar(x)))) %&gt;% pivot_longer(everything(), names_to = &quot;Nombre_Columna&quot;, values_to = &quot;leng_min&quot;) nas_values_char &lt;- censo %&gt;% summarise(across(where(is.character) , function(x) sum(is.na(x)))) %&gt;% pivot_longer(everything(), names_to = &quot;Nombre_Columna&quot;, values_to = &quot;Num_nas_char&quot;) Resumen de variables numéricas max_values &lt;- censo2 %&gt;% summarise(across(where(is.numeric) | where(is.integer), max)) %&gt;% pivot_longer(everything(), names_to = &quot;Nombre_Columna&quot;, values_to = &quot;Valor_Maximo&quot;) min_values &lt;- censo2 %&gt;% summarise(across(where(is.numeric) | where(is.integer), min)) %&gt;% pivot_longer(everything(), names_to = &quot;Nombre_Columna&quot;, values_to = &quot;Valor_Minimo&quot;) media_values &lt;- censo2 %&gt;% summarise(across(where(is.numeric) | where(is.integer), mean)) %&gt;% pivot_longer(everything(), names_to = &quot;Nombre_Columna&quot;, values_to = &quot;Valor_Media&quot;) mediana_values &lt;- censo2 %&gt;% summarise(across(where(is.numeric) | where(is.integer), median)) %&gt;% pivot_longer(everything(), names_to = &quot;Nombre_Columna&quot;, values_to = &quot;Valor_Mediana&quot;) SD_values &lt;- censo2 %&gt;% summarise(across(where(is.numeric) | where(is.integer), sd)) %&gt;% pivot_longer(everything(), names_to = &quot;Nombre_Columna&quot;, values_to = &quot;Valor_sd&quot;) nas_values &lt;- censo %&gt;% summarise(across(where(is.numeric) | where(is.integer), function(x)sum(is.na(x)))) %&gt;% pivot_longer(everything(), names_to = &quot;Nombre_Columna&quot;, values_to = &quot;Num_nas&quot;) Combinación de toda la información de resumen resumen2 &lt;- reduce( list(nas_values_char, min_char, max_char, nas_values, SD_values, mediana_values, media_values, min_values, max_values), full_join, by = join_by(Nombre_Columna)) %&gt;% full_join(x = resumen, y = ., by = join_by(Nombre_Columna)) Guardando los resultados del resumen en un archivo de Excel openxlsx::write.xlsx(resumen2, file = &quot;Recursos/01_Input_Validation/Data/Estado_base_despues.xlsx&quot;) Guardando el dataset estandarizado saveRDS(censo2, file = &quot;Recursos/01_Input_Validation/Data/censo_estandarizado.rds&quot;) En este bloque de código, estamos creando resúmenes de las variables del conjunto de datos para comprender sus características. Calculamos diferentes medidas tanto para variables de tipo carácter como numéricas, como el máximo, mínimo, media, mediana y desviación estándar. Además, contamos los valores faltantes para variables de tipo carácter. "],["filtrado-y-refinamiento-de-datos-del-censo.html", "Chapter 3 Filtrado y Refinamiento de Datos del Censo", " Chapter 3 Filtrado y Refinamiento de Datos del Censo En el proceso de mejorar y depurar una base de datos del censo, es imperativo establecer reglas coherentes y replicables. En este contexto, el procedimiento de “Filtrado y Refinamiento de Datos del Censo” se vuelve esencial para mejorar la calidad de los datos y eliminar información irrelevante. A lo largo de los siguientes bloques de código, exploraremos cómo se aplicaron diversos filtros y técnicas de refinamiento a los datos del censo. Estos códigos nos guiarán a través de un proceso crucial para asegurar que los datos sean confiables y adecuados para un análisis posterior. Colectivamente, estos pasos nos permitirán obtener información más precisa y valiosa a partir de los datos del censo. "],["lectura-de-bibliotecas-bases-de-datos-y-otros-insumos.html", "3.1 Lectura de Bibliotecas, Bases de Datos y Otros Insumos", " 3.1 Lectura de Bibliotecas, Bases de Datos y Otros Insumos En esta sección, comenzamos cargando las bibliotecas necesarias utilizadas en todo el procesamiento. Además, definimos las columnas que se conservarán después de aplicar los filtros. También realizamos ajustes necesarios en las bases de datos, considerando actualizaciones en los códigos de las Unidades Geográficas Mínimas (UGM). # Load necessary libraries library(tidyverse) # For data manipulation and visualization library(data.table) # For efficient data handling library(openxlsx) # For reading/writing Excel files library(magrittr) # For pipe operators select &lt;- dplyr::select # Alias for dplyr&#39;s select function cat(&quot;\\f&quot;) # Clear console output ## Census data reading ## Selection of columns of interest in the census. Nombre_Columna &lt;- c( &quot;un_ID&quot; , &quot;PROV_ID&quot; , &quot;CANT_ID&quot; , &quot;DIST_ID&quot; , &quot;UGM_ID&quot; , &quot;LLAVEV&quot; , &quot;V01_TIPO_VIVIENDA&quot; , &quot;V02_OCUPACION_VIVIENDA&quot; , &quot;H01A_TOTAL_PERSONAS&quot; , &quot;greenpoint2&quot;, &quot;Filtros&quot; ) Lectura de Datos de Vivienda sin Coordenadas. En esta sección, leemos los datos de vivienda desde un archivo CSV que no incluye coordenadas. Luego transformamos los datos al formato requerido, incluyendo variables como el ID de provincia, el ID de cantón y el ID de distrito basados en los códigos proporcionados. El conjunto de datos resultante se utilizará para análisis y procesamiento adicionales. Viviendas_sin_coordenadas &lt;- read_csv2(&quot;Recursos/02_Census_Filters/Data/Viviendas sin coordenadas.csv&quot;) # Transmute data to required format Viviendas_sin_coordenadas %&lt;&gt;% transmute( LLAVEV, PROV_ID = str_sub(CODIGO_PCD, 1,1), CANT_ID = str_sub(CODIGO_PCD, 1,3), DIST_ID = as.character(CODIGO_PCD), UGM_ID = paste0(CODIGO_PCD , ID_UGM), H01A_TOTAL_PERSONAS = H01A_TOTAL_RESIDENTES_HAB) Cambio de Códigos UGM en los Datos de Vivienda. En esta sección, modificamos los códigos UGM en los datos de vivienda para garantizar la consistencia y precisión. Algunos códigos UGM se actualizan de acuerdo con asignaciones predefinidas. Este paso es crucial para mantener la uniformidad de los datos para análisis posteriores. Viviendas_sin_coordenadas %&lt;&gt;% mutate(UGM_ID = case_when( UGM_ID == &quot;10108228&quot; ~ &quot;10108158&quot;, UGM_ID == &quot;10805037&quot; ~ &quot;10807037&quot;, UGM_ID == &quot;11803124&quot; ~ &quot;11803024&quot;, UGM_ID == &quot;11803150&quot; ~ &quot;11803050&quot;, UGM_ID == &quot;11803151&quot; ~ &quot;11803051&quot;, UGM_ID == &quot;20302131&quot; ~ &quot;20302031&quot;, UGM_ID == &quot;21305106&quot; ~ &quot;21305006&quot;, UGM_ID == &quot;30101232&quot; ~ &quot;30101132&quot;, UGM_ID == &quot;30201354&quot; ~ &quot;30201254&quot;, UGM_ID == &quot;30302158&quot; ~ &quot;30302133&quot;, UGM_ID == &quot;30305186&quot; ~ &quot;30305086&quot;, TRUE ~UGM_ID )) Leer los Datos del Censo Estandarizados. En esta sección, leemos los datos del censo estandarizados desde un archivo RDS (R Data Serialization) almacenado. Al igual que en el paso anterior, ajustamos los códigos UGM para mantener la consistencia de los datos. Los datos del censo estandarizados servirán como base para los procesos posteriores de filtrado y refinamiento. censo1 &lt;- readRDS(&quot;Recursos/02_Census_Filters/Data/censo_estandarizado.rds&quot;) %&gt;% mutate(UGM_ID = case_when( UGM_ID == &quot;10108228&quot; ~ &quot;10108158&quot;, UGM_ID == &quot;10805037&quot; ~ &quot;10807037&quot;, UGM_ID == &quot;11803124&quot; ~ &quot;11803024&quot;, UGM_ID == &quot;11803150&quot; ~ &quot;11803050&quot;, UGM_ID == &quot;11803151&quot; ~ &quot;11803051&quot;, UGM_ID == &quot;20302131&quot; ~ &quot;20302031&quot;, UGM_ID == &quot;21305106&quot; ~ &quot;21305006&quot;, UGM_ID == &quot;30101232&quot; ~ &quot;30101132&quot;, UGM_ID == &quot;30201354&quot; ~ &quot;30201254&quot;, UGM_ID == &quot;30302158&quot; ~ &quot;30302133&quot;, UGM_ID == &quot;30305186&quot; ~ &quot;30305086&quot;, TRUE ~UGM_ID )) Agregando la Base de Edad y Sexo. En esta sección, incorporamos la base de edad y sexo al análisis. La base de edad y sexo se lee desde un archivo RDS almacenado. Al igual que en los pasos anteriores, garantizamos la consistencia ajustando los códigos UGM. La base de edad y sexo proporciona información demográfica valiosa y se utilizará en los procedimientos posteriores de filtrado y refinamiento. censo_sexo_edad &lt;- readRDS(&quot;Recursos/02_Census_Filters/Data/Censo con grupos por sexo.rds&quot;) %&gt;% select(-H01A_TOTAL_PERSONAS ) %&gt;% mutate(UGM_ID = case_when( UGM_ID == &quot;10108228&quot; ~ &quot;10108158&quot;, UGM_ID == &quot;10805037&quot; ~ &quot;10807037&quot;, UGM_ID == &quot;11803124&quot; ~ &quot;11803024&quot;, UGM_ID == &quot;11803150&quot; ~ &quot;11803050&quot;, UGM_ID == &quot;11803151&quot; ~ &quot;11803051&quot;, UGM_ID == &quot;20302131&quot; ~ &quot;20302031&quot;, UGM_ID == &quot;21305106&quot; ~ &quot;21305006&quot;, UGM_ID == &quot;30101232&quot; ~ &quot;30101132&quot;, UGM_ID == &quot;30201354&quot; ~ &quot;30201254&quot;, UGM_ID == &quot;30302158&quot; ~ &quot;30302133&quot;, UGM_ID == &quot;30305186&quot; ~ &quot;30305086&quot;, TRUE ~UGM_ID )) 3.1.1 Inner Join para Agregar la Base de Edad y Sexo En esta sección, se realiza una operación de unión interna para integrar la base de edad y sexo con los datos censales. La diferencia en el recuento de filas entre las dos bases corresponde a los hogares censados en papel que se incluyen más adelante en el proceso. Se compara el número de filas en la base de edad y sexo con los datos del censo y los datos de viviendas sin coordenadas para verificar la coincidencia. ## The difference between the bases corresponds to paper-censused households ## that are included later nrow(censo_sexo_edad) - nrow(censo1) nrow(Viviendas_sin_coordenadas) ## Inner join to add the age-sex base censo1 &lt;- inner_join( censo1, censo_sexo_edad, join_by( un_ID, PROV_ID, CANT_ID, DIST_ID, UGM_ID, LLAVEV, V01_TIPO_VIVIENDA, V02_OCUPACION_VIVIENDA ) ) El código comienza calculando la diferencia en el recuento de filas entre la base de edad y sexo (censo_sexo_edad) y los datos censales existentes (censo1). Esta diferencia representa el número de hogares censados en papel que aún no se han incluido en los datos del censo. Además, se determina el número de filas en los datos de viviendas sin coordenadas (Viviendas_sin_coordenadas) como referencia. A continuación, se aplica la operación inner_join para combinar la base de edad y sexo con los datos censales. La función join_by especifica las columnas utilizadas para la operación de unión, asegurando una integración completa de los datos de ambas fuentes. Este proceso mejora el conjunto de datos al incorporar información demográfica importante para un análisis posterior. "],["aplicación-de-filtros-y-análisis-de-datos.html", "3.2 Aplicación de filtros y análisis de datos", " 3.2 Aplicación de filtros y análisis de datos En esta sección, vamos a guiarlo a través del proceso de aplicar varios filtros y realizar análisis de datos en los datos censales refinados. 3.2.1 Aplicación del primer filtro: categorización de hogares con residentes y determinación del estado de greenpoint En este bloque de código, introducimos el primer filtro al categorizar los hogares como con residentes (‘si’) o vacíos (‘no’) basándonos en el número total de residentes en cada hogar. Además, determinamos el estado de greenpoint de cada hogar, considerando si el valor de greenpoint es ‘0’ y el valor de ‘personas’ es ‘si’. La columna ‘greenpoint’ se actualiza en consecuencia. # Create &#39;personas&#39; column to categorize households with or without residents censo1 %&lt;&gt;% mutate(personas = if_else(H01A_TOTAL_PERSONAS &gt; 0, &quot;si&quot;, &quot;no&quot;)) # Assign greenpoint status based on conditions censo1 %&lt;&gt;% mutate(greenpoint = if_else(greenpoint == &quot;0&quot; &amp; personas == &quot;si&quot;, &quot;1&quot;, greenpoint)) greenpoint: La vivienda se reporta como censada en el mapa de puntos. Analizando la distribución de greenpoint En este código se calcula la distribución del estado de greenpoint entre los hogares. Agrupa los datos según el estado de ‘greenpoint’, cuenta el número de hogares en cada categoría y calcula la distribución porcentual. Los resultados ofrecen información sobre la prevalencia del estado de greenpoint entre los datos censales. greenpoint_distribution &lt;- censo1 %&gt;% group_by(greenpoint) %&gt;% tally() %&gt;% # Counting households with and without greenpoint mutate(percentage = 100 * n / sum(n)) # Calculating the percentage of each category greenpoint_distribution greenpoint n percentage 0 471456 27.0448 1 1053477 60.4321 NA 218308 12.5231 Resumiendo las características de los hogares por estado de greenpoint Este bloque de código resume las características de los hogares según su estado de greenpoint. Calcula los números mínimos y máximos de residentes en los hogares, cuenta los valores faltantes para el número total de residentes y proporciona el recuento total de hogares para cada categoría de greenpoint. household_summary &lt;- censo1 %&gt;% group_by(greenpoint) %&gt;% summarise(min = min(H01A_TOTAL_PERSONAS), # Minimum number of residents in households max = max(H01A_TOTAL_PERSONAS), # Maximum number of residents in households num_na = sum(is.na(H01A_TOTAL_PERSONAS)), # Number of missing values for the total number of residents total = n()) # Total number of households household_summary greenpoint min max num_na total 0 0 0 0 471456 1 0 261 0 1053477 NA NA NA 218308 218308 Creación de una tabla de contingencia para la ocupación y el estado de greenpoint En esta sección, se genera una tabla de contingencia para explorar la relación entre la ocupación y el estado de greenpoint. La tabla cruza la columna ‘V02_OCUPACION_VIVIENDA’ (ocupación) con la columna ‘greenpoint’, teniendo en cuenta los valores faltantes. Esto proporciona una representación visual de cómo se distribuyen estas dos variables entre los hogares. occupancy_greenpoint_table &lt;- table(censo1$V02_OCUPACION_VIVIENDA, censo1$greenpoint, useNA = &quot;a&quot;) occupancy_greenpoint_table 0 1 NA 1 0 772625 0 2 471456 3853 0 3 0 92465 0 4 0 31187 0 5 0 52463 0 6 0 23845 0 7 0 2168 0 8 0 74871 0 9 0 0 218308 NA 0 0 0 Aplicación del segundo filtro y refinamiento Continuando con el proceso de refinamiento, se aplica el siguiente filtro para categorizar aún más los hogares en función de criterios adicionales. censo2 &lt;- censo1 %&gt;% mutate( greenpoint2 = case_when( H01A_TOTAL_PERSONAS &gt; 0 ~ &quot;Censado con informacion n&gt;0&quot;, RESUL_ENTREVISTA_VIV %in% c(1) &amp; H01A_TOTAL_PERSONAS == 0 ~ &quot;Censado con informacion n=0&quot;, RESUL_ENTREVISTA_VIV %in% c(3, 4) ~ &quot;Sin informacion pero n&gt;0&quot;, is.na(greenpoint) &amp; is.na(personas) ~ &quot;Sin informacion pero n&gt;=0&quot;, V02_OCUPACION_VIVIENDA == &quot;8&quot; ~ &quot;Sin informacion pero n&gt;=0&quot;, TRUE ~ &quot;Resto&quot; ) ) Introducimos el estado “greenpoint2” para categorizar aún más los hogares en función de diversas condiciones. Esto se basa en una combinación de factores como el número de residentes, los resultados de las entrevistas y la ocupación de la vivienda. Cada hogar se asigna a una categoría específica, como “Censado con información n&gt;0”, “Censado con información n=0” y “Sin información pero n&gt;0”, entre otros. Esto proporciona una forma más detallada de describir el estado de los hogares en función de diferentes criterios. readRDS(&quot;Recursos/02_Census_Filters/RecurseBooks/census2.rds&quot;) %&gt;% head(10) %&gt;% tba() 3.2.2 Aplicación del segundo filtro: Criterio WorldPop A partir del paso 1, también incluimos todos los hogares con la variable WorldPop (WP) que se encuentran dentro de 1 desviación estándar del valor promedio. Sin embargo, si estos hogares tienen cero residentes en la variable de interés, marcamos esa variable como “No Disponible” (NA). Calcular estadísticas resumen para la variable ‘wpop_sum’ En primer lugar, calculamos estadísticas resumen para la variable ‘wpop_sum’, que es una covariable relacionada con WorldPop. Las estadísticas resumen incluyen el promedio, la desviación estándar, el valor mínimo y máximo de ‘wpop_sum’. Estas estadísticas nos ayudan a establecer los umbrales para el filtro y se guardan en un archivo resumen. wpop_summary &lt;- censo2 %&gt;% distinct(UGM_ID,wpop_sum) %&gt;% summarise(media = mean(wpop_sum), # Mean value of &#39;wpop_sum&#39; sd = sd(wpop_sum), # Standard deviation of &#39;wpop_sum&#39; min = min(wpop_sum), # Minimum value of &#39;wpop_sum&#39; max = max(wpop_sum)) # Maximum value of &#39;wpop_sum&#39; wpop_summary media sd min max 96.9652 143.1986 0 6214.269 Cálculo de umbrales inferior y superior Utilizamos las estadísticas resumen para calcular los umbrales inferior y superior basados en una desviación estándar del promedio. Estos umbrales nos ayudarán a identificar los hogares que cumplen con los criterios del segundo filtro. # Calculate the lower and upper thresholds based on one standard deviation from the mean li &lt;- 96.96515 - 143.1986 * 1 # Lower threshold ls &lt;- 96.96515 + 143.1986 * 1 # Upper threshold Identificamos y contamos los hogares que cumplen con los criterios del segundo filtro. Nos centramos en los hogares con cero residentes (‘H01A_TOTAL_PERSONAS’) pero que tienen valores de ‘wpop_sum’ fuera del umbral calculado. Realizamos esta cuenta y la agrupamos según la variable ‘V02_OCUPACION_VIVIENDA’. # Identify and count households that meet the criteria for the second filter filter_2_counts &lt;- censo2 %&gt;% filter(H01A_TOTAL_PERSONAS == 0, wpop_sum &gt; ls | wpop_sum &lt; li) %&gt;% group_by(V02_OCUPACION_VIVIENDA) %&gt;% summarise(n = n()) filter_2_counts V02_OCUPACION_VIVIENDA n 2 129652 3 22968 4 8210 5 10514 6 4635 7 532 8 17160 Aplicación del Segundo Filtro y Actualizaciones de Columnas Aplicamos el segundo filtro a los hogares y actualizamos las columnas ‘greenpoint2’ y ‘Filtros’ en consecuencia. La columna ‘greenpoint2’ se actualiza para reflejar la nueva clasificación basada en el Criterio WorldPop, mientras que la columna ‘Filtros’ indica la aplicación del Criterio WorldPop o se establece como NA según corresponda. # Apply the second filter and update &#39;greenpoint2&#39; and &#39;Filtros&#39; columns censo3 &lt;- censo2 %&gt;% mutate( greenpoint2 = case_when( H01A_TOTAL_PERSONAS == 0 &amp; (wpop_sum &gt; ls | wpop_sum &lt; li) ~ &quot;Sin informacion pero n&gt;=0&quot;, TRUE ~ greenpoint2 ), Filtros = case_when( H01A_TOTAL_PERSONAS == 0 &amp; (wpop_sum &gt; ls | wpop_sum &lt; li) ~ &quot;Criterio WorldPop&quot;, TRUE ~ NA_character_ ) ) un_ID PROV_ID CANT_ID DIST_ID UGM_ID LLAVEV RESUL_ENTREVISTA_VIV TIPO_VIVIENDA_PRECENSO V01_TIPO_VIVIENDA V02_OCUPACION_VIVIENDA H01A_TOTAL_PERSONAS greenpoint ugm_viviendas_totales_censo ugm_viviendas_ocupadas_censo ugm_viviendas_desocupadas_censo ugm_peligrosidad ugm_problema_de_acceso ugm_riesgos_amenazas ugm_cobertura_telecomunicaciones asent ppp_CRI_v2 elev indig aprot dist_permisos_de_construccion_2011_2022 dist_poblacion_proyeccion_ajustada_2022 dist_poblacion_ccss_abril_2023 dist_matricula_educacion_primaria_2021 dist_codigo_urbanidad GHS_BUILT_S_E2020_GLOBE_R2023A_5367_CRI urban_coverfraction crops_coverfraction ebais_tt escu_tt igl_tt prov_nl_mean cant_nl_mean dist_nl_mean wpop_sum HOMBRES_GRUPO1_sum HOMBRES_GRUPO2_sum HOMBRES_GRUPO3_sum HOMBRES_GRUPO4_sum HOMBRES_GRUPO5_sum HOMBRES_GRUPO6_sum HOMBRES_GRUPO7_sum HOMBRES_GRUPO8_sum HOMBRES_GRUPO9_sum HOMBRES_GRUPO10_sum HOMBRES_GRUPO11_sum HOMBRES_GRUPO12_sum HOMBRES_GRUPO13_sum HOMBRES_GRUPO14_sum HOMBRES_GRUPO15_sum HOMBRES_GRUPO16_sum HOMBRES_GRUPO17_sum HOMBRES_GRUPO18_sum HOMBRES_GRUPO19_sum HOMBRES_GRUPO20_sum MUJERES_GRUPO1_sum MUJERES_GRUPO2_sum MUJERES_GRUPO3_sum MUJERES_GRUPO4_sum MUJERES_GRUPO5_sum MUJERES_GRUPO6_sum MUJERES_GRUPO7_sum MUJERES_GRUPO8_sum MUJERES_GRUPO9_sum MUJERES_GRUPO10_sum MUJERES_GRUPO11_sum MUJERES_GRUPO12_sum MUJERES_GRUPO13_sum MUJERES_GRUPO14_sum MUJERES_GRUPO15_sum MUJERES_GRUPO16_sum MUJERES_GRUPO17_sum MUJERES_GRUPO18_sum MUJERES_GRUPO19_sum MUJERES_GRUPO20_sum personas greenpoint2 Filtros 0218491 1 101 10101 10101001 10101001001001 3 VIVIENDA EN APARTAMENT 01 2 0 0 0 0 0 2 2 2 1 0 17.4872 1157.488 0 0 413 3233 14597 1374 1 3773 100 0 44.0027 0 0.9933 10.802 62.9502 63 34.5930 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 no Sin informacion pero n&gt;0 NA 0141265 1 101 10101 10101002 10101001002001 1 VIVIENDA EN APARTAMENT 01 1 6 1 2 2 0 2 2 2 1 0 17.5313 1156.738 0 0 413 3233 14597 1374 1 4907 100 0 44.0000 0 0.0000 10.802 62.9502 63 9.4928 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 2 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 si Censado con informacion n&gt;0 NA 0151378 1 101 10101 10101002 10101001002002 1 VIVIENDA INDEPENDIENTE 01 1 3 1 2 2 0 2 2 2 1 0 17.5313 1158.038 0 0 413 3233 14597 1374 1 4907 100 0 44.9932 0 0.0000 10.802 62.9502 63 9.4928 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 si Censado con informacion n&gt;0 NA 0218056 1 101 10101 10101003 10101001003006 3 00VIVIENDA EN EDIFICIO 01 2 0 0 5 0 5 2 2 2 1 0 15.9573 1152.401 0 0 413 3233 14597 1374 1 4794 100 0 44.9932 0 0.0000 10.802 62.9502 63 13.1767 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 no Sin informacion pero n&gt;0 NA 0217145 1 101 10101 10101003 10101001003005 1 VIVIENDA INDEPENDIENTE 09 3 0 1 5 0 5 2 2 2 1 0 15.9573 1156.873 0 0 413 3233 14597 1374 1 4794 100 0 45.0000 0 0.9960 10.802 62.9502 63 13.1767 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 no Censado con informacion n=0 NA 0216224 1 101 10101 10101003 10101001003003 1 VIVIENDA INDEPENDIENTE 01 3 0 1 5 0 5 2 2 2 1 0 15.8496 1157.138 0 0 413 3233 14597 1374 1 3604 100 0 44.0027 0 0.9933 10.802 62.9502 63 13.1767 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 no Censado con informacion n=0 NA 0215255 1 101 10101 10101003 10101001003001 1 VIVIENDA EN APARTAMENT 01 3 0 1 5 0 5 2 2 2 1 0 15.8496 1157.801 0 0 413 3233 14597 1374 1 4794 100 0 44.0027 0 1.0000 10.802 62.9502 63 13.1767 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 no Censado con informacion n=0 NA 0215972 1 101 10101 10101003 10101001003002 1 VIVIENDA INDEPENDIENTE 01 3 0 1 5 0 5 2 2 2 1 0 15.8496 1157.138 0 0 413 3233 14597 1374 1 3604 100 0 44.0027 0 0.9933 10.802 62.9502 63 13.1767 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 no Censado con informacion n=0 NA 0216229 1 101 10101 10101003 10101001003004 1 VIVIENDA INDEPENDIENTE 01 3 0 1 5 0 5 2 2 2 1 0 15.8496 1157.138 0 0 413 3233 14597 1374 1 3604 100 0 44.0027 0 0.9933 10.802 62.9502 63 13.1767 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 no Censado con informacion n=0 NA 0925743 1 101 10101 10101004 10101001004002 3 VIVIENDA INDEPENDIENTE 04 2 0 0 1 0 1 2 2 2 1 0 17.4872 1158.147 0 0 413 3233 14597 1374 1 3773 100 0 44.0000 0 0.0027 10.802 62.9502 63 13.6008 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 no Sin informacion pero n&gt;0 NA Resumen de datos basado en ‘greenpoint2’ Resumimos los datos en función de la variable ‘greenpoint2’ actualizada. Calculamos la distribución y los porcentajes de hogares en cada categoría de ‘punto verde2’. Estos resúmenes nos ayudan a comprender el impacto del filtro en la clasificación de los hogares. # Summarizing the data based on the &#39;greenpoint2&#39; variable summary_greenpoint2 &lt;- censo3 %&gt;% group_by(greenpoint2) %&gt;% tally() %&gt;% mutate(percentage = 100 * n / sum(n)) greenpoint2 n percentage Censado con informacion n=0 212980 12.2175 Censado con informacion n&gt;0 776478 44.5422 Sin informacion pero n&gt;0 341804 19.6074 Sin informacion pero n&gt;=0 411979 23.6329 Resumen de Datos Basado en ‘greenpoint2’ y ‘Filtros’ Generamos un resumen adicional que considera la combinación de las variables ‘greenpoint2’ y ‘Filtros’. Esto proporciona información más detallada sobre cómo el Criterio WorldPop afecta las categorías existentes. # Summarizing the data based on the combination of &#39;greenpoint2&#39; and &#39;Filtros&#39; variables summary_greenpoint2_filtros &lt;- censo3 %&gt;% group_by(greenpoint2, Filtros) %&gt;% tally() %&gt;% mutate(percentage = 100 * n / sum(n)) summary_greenpoint2_filtros greenpoint2 Filtros n percentage Censado con informacion n=0 NA 212980 100.0000 Censado con informacion n&gt;0 NA 776478 100.0000 Sin informacion pero n&gt;0 NA 341804 100.0000 Sin informacion pero n&gt;=0 Criterio WorldPop 193671 47.0099 Sin informacion pero n&gt;=0 NA 218308 52.9901 3.2.3 Resumen de estadísticas basado en ‘greenpoint2’ Calculamos estadísticas adicionales para las categorías ‘greenpoint2’. Estas estadísticas incluyen el número mínimo, máximo, de valores faltantes y el número total de hogares en cada categoría. Estos datos son esenciales para comprender la distribución de los residentes en los hogares filtrados. Cada una de estas etapas contribuye al proceso de aplicar el segundo filtro y refinar los datos del censo con base en el Criterio WorldPop. Los resúmenes y datos generados son útiles para análisis posteriores y se guardan para referencia futura. # Summarizing the data for &#39;greenpoint2&#39; variable summary_greenpoint2_stats &lt;- censo3 %&gt;% group_by(greenpoint2) %&gt;% summarise(min = min(H01A_TOTAL_PERSONAS), max = max(H01A_TOTAL_PERSONAS), num_na = sum(is.na(H01A_TOTAL_PERSONAS)), total = n()) summary_greenpoint2_stats greenpoint2 min max num_na total Censado con informacion n=0 0 0 0 212980 Censado con informacion n&gt;0 1 261 0 776478 Sin informacion pero n&gt;0 0 0 0 341804 Sin informacion pero n&gt;=0 NA NA 218308 411979 3.2.4 Definición del tercer filtro En esta sección, presentamos la implementación del tercer filtro, basándose en los cimientos establecidos por los Filtros 1 y 2. El tercer filtro se dirige a hogares dentro de las UGM que fueron encuestados después de un intervalo mayor a 20 días y, a pesar de estar clasificados como desocupados, allí existe una falta de certeza sobre su estado de ocupación. Estos hogares se reclasifican como de estatus desconocido. Lectura del Archivo ‘Desocupadas fuera periodo.xlsx’ Comenzamos leyendo el archivo ‘Desocupadas fuera periodo.xlsx’ para recopilar información sobre hogares que estaban desocupados pero visitados fuera del intervalo estándar. Extraemos específicamente la columna ‘UGM_ID’ para un análisis más detallado. # Reading the &#39;Desocupadas fuera periodo.xlsx&#39; file and selecting the UGM_ID column upms_reporte &lt;- openxlsx::read.xlsx( xlsxFile = &quot;Recursos/02_Census_Filters/Data/Desocupadas fuera periodo.xlsx&quot;) %&gt;% select(UGM_ID = ID_UGM) Aplicación de filtros basados en ‘upms_reporte’ y condiciones específicas Utilizando la información recopilada de ‘upms_reporte’ y considerando ciertas condiciones, aplicamos filtros adicionales a los datos existentes. Actualizamos las columnas ‘greenpoint2’ y ‘Filtros’ según los criterios especificados. # Creating &#39;censo4&#39; by applying filters based on &#39;upms_reporte&#39; and specific conditions censo4 &lt;- censo3 %&gt;% mutate( greenpoint2 = case_when( UGM_ID %in% upms_reporte$UGM_ID &amp; H01A_TOTAL_PERSONAS == 0 ~ &quot;Sin informacion pero n&gt;=0&quot;, TRUE ~ greenpoint2 ), Filtros = case_when( UGM_ID %in% upms_reporte$UGM_ID &amp; H01A_TOTAL_PERSONAS == 0 ~ &quot;Fuera de periodo(20 días)&quot;, TRUE ~ Filtros ) ) Aplicar filtros adicionales y crear valores de ‘Filtros’ Procedemos a refinar aún más los datos aplicando filtros adicionales. Los valores de ‘Filtros’ se actualizan en función de diversas condiciones como el número de residentes, el resultado de la entrevista (‘RESUL_ENTREVISTA_VIV’) y la ocupación de la vivienda (‘V02_OCUPACION_VIVIENDA’). # Applying additional filters and creating &#39;Filtros&#39; values censo4 %&lt;&gt;% mutate(Filtros = case_when( is.na(Filtros) &amp; H01A_TOTAL_PERSONAS &gt; 0 ~ &quot;Número de personas mayor a 0&quot;, is.na(Filtros) &amp; RESUL_ENTREVISTA_VIV %in% c(1) &amp; H01A_TOTAL_PERSONAS == 0 ~ &quot;Entrevista igual a 1 y Número de personas igual a 0&quot;, is.na(Filtros) &amp; RESUL_ENTREVISTA_VIV %in% c(3,4) ~ &quot;Entrevista es 3 o 4&quot;, is.na(Filtros) &amp; is.na(greenpoint) &amp; is.na(personas) ~ &quot;Sin conteo de personas&quot;, is.na(Filtros) &amp; V02_OCUPACION_VIVIENDA == &quot;8&quot; ~ &quot;Ocupación de la vivienda es 8&quot;, TRUE ~ Filtros )) Resumir datos basados en las variables ‘greenpoint2’ y ‘Filtros’ Generamos un resumen de los datos en base a las variables ‘greenpoint2’ y ‘Filtros’ actualizadas. El resumen proporciona información sobre la distribución de hogares en diferentes categorías. # Summarizing data based on &#39;greenpoint2&#39; and &#39;Filtros&#39; variables summary_greenpoint2_filtros &lt;- censo4 %&gt;% group_by(greenpoint2, Filtros) %&gt;% tally() %&gt;% ungroup() %&gt;% mutate(percentage = 100 * n / sum(n)) greenpoint2 Filtros n percentage Censado con informacion n=0 Entrevista igual a 1 y Número de personas igual a 0 175921 10.0916 Censado con informacion n&gt;0 Número de personas mayor a 0 776478 44.5422 Sin informacion pero n&gt;0 Entrevista es 3 o 4 285810 16.3953 Sin informacion pero n&gt;=0 Criterio WorldPop 135370 7.7654 Sin informacion pero n&gt;=0 Fuera de periodo(20 días) 151354 8.6823 Sin informacion pero n&gt;=0 Sin conteo de personas 218308 12.5231 Resumir datos basados en la variable ‘greenpoint2’ De manera similar, creamos otro resumen de los datos, esta vez centrándonos únicamente en la variable ‘puntoverde2’. Este resumen nos ayuda a comprender el impacto del tercer filtro en la clasificación de los hogares. # Summarizing data based on &#39;greenpoint2&#39; variable summary_greenpoint2 &lt;- censo4 %&gt;% group_by(greenpoint2) %&gt;% tally() %&gt;% mutate(percentage = 100 * n / sum(n)) greenpoint2 n percentage Censado con informacion n=0 175921 10.0916 Censado con informacion n&gt;0 776478 44.5422 Sin informacion pero n&gt;0 285810 16.3953 Sin informacion pero n&gt;=0 505032 28.9709 3.2.5 Combinando casas no coordinadas Selección de casas no coordinadas del conjunto de datos ‘censo_sexo_edad’ y unión interna con ‘Viviendas_sin_coordenadas’ # Filtering non-coordinated houses from &#39;censo_sexo_edad&#39; dataset Viviendas_sin_coordenadas2 &lt;- censo_sexo_edad %&gt;% filter(is.na(un_ID)) %&gt;% inner_join(Viviendas_sin_coordenadas) %&gt;% # Adding a unique identifier &#39;un_ID&#39; to the newly joined houses mutate(un_ID = paste0(&quot;A&quot;, 1:n())) # Adding the newly joined houses to the &#39;censo4&#39; dataset censo4 &lt;- bind_rows(censo4, Viviendas_sin_coordenadas2) # Modifying &#39;Filtros&#39; column based on &#39;greenpoint2&#39; values censo4 %&lt;&gt;% mutate(Filtros = ifelse(is.na(greenpoint2), &quot;Censado en papel&quot;, greenpoint2)) # Modifying &#39;greenpoint2&#39; column based on conditions censo4 %&lt;&gt;% mutate(greenpoint2 = case_when( Filtros == &quot;Censado en papel&quot; &amp; H01A_TOTAL_PERSONAS == 0 ~ &quot;Papel n=0&quot;, Filtros == &quot;Censado en papel&quot; &amp; H01A_TOTAL_PERSONAS &gt; 0 ~ &quot;Papel n&gt;0&quot;, TRUE ~greenpoint2 )) 3.2.6 Agregación de estadísticas y resúmenes # Summarizing statistics for the &#39;censo4&#39; dataset based on &#39;greenpoint2&#39; column summary1 &lt;- censo4 %&gt;% group_by(greenpoint2) %&gt;% summarise(min = min(H01A_TOTAL_PERSONAS), max = max(H01A_TOTAL_PERSONAS), num_na = sum(is.na(H01A_TOTAL_PERSONAS)), total = n()) greenpoint2 min max num_na total Censado con informacion n=0 0 0 0 175921 Censado con informacion n&gt;0 1 261 0 776478 Papel n=0 0 0 0 1334 Papel n&gt;0 1 3500 0 23344 Sin informacion pero n&gt;0 0 0 0 285810 Sin informacion pero n&gt;=0 NA NA 218308 505032 Resumir estadísticas para el conjunto de datos ‘censo4’ basado en las columnas ‘greenpoint2’ y ‘Filtros’ summary2 &lt;- censo4 %&gt;% group_by(greenpoint2, Filtros) %&gt;% summarise(min = min(H01A_TOTAL_PERSONAS), max = max(H01A_TOTAL_PERSONAS), num_na = sum(is.na(H01A_TOTAL_PERSONAS)), total = n()) greenpoint2 Filtros min max num_na total Censado con informacion n=0 Censado con informacion n=0 0 0 0 175921 Censado con informacion n&gt;0 Censado con informacion n&gt;0 1 261 0 776478 Papel n=0 Censado en papel 0 0 0 1334 Papel n&gt;0 Censado en papel 1 3500 0 23344 Sin informacion pero n&gt;0 Sin informacion pero n&gt;0 0 0 0 285810 Sin informacion pero n&gt;=0 Sin informacion pero n&gt;=0 NA NA 218308 505032 Resumir estadísticas para el conjunto de datos ‘censo4’ basado en las columnas ‘greenpoint2’ y ‘Filtros’ summary3 &lt;- censo4 %&gt;% group_by(greenpoint2, Filtros) %&gt;% summarise(total = n(), nas = sum(is.na(H01A_TOTAL_PERSONAS))) greenpoint2 Filtros total nas Censado con informacion n=0 Censado con informacion n=0 175921 0 Censado con informacion n&gt;0 Censado con informacion n&gt;0 776478 0 Papel n=0 Censado en papel 1334 0 Papel n&gt;0 Censado en papel 23344 0 Sin informacion pero n&gt;0 Sin informacion pero n&gt;0 285810 0 Sin informacion pero n&gt;=0 Sin informacion pero n&gt;=0 505032 218308 Contar apariciones de ‘un_ID’ y filtrar duplicados duplicated_un_ID &lt;- censo4 %&gt;% group_by(un_ID) %&gt;% tally() %&gt;% filter(n &gt; 1) duplicated_un_ID 3.2.7 Extraer y guardar subconjunto # Selecting columns from &#39;censo4&#39; that match &#39;Nombre_Columna&#39; and contain &#39;GRUPO&#39; paso &lt;- censo4 %&gt;% select( all_of(Nombre_Columna[11]), matches(&quot;GRUPO&quot;) ) # Saving the &#39;paso&#39; dataset as an RDS file in the specified directory saveRDS(paso, file = &quot;Recursos/02_Census_Filters/data/censo_viviendas.rds&quot;) "],["estandarización-y-validación-de-covariables.html", "Chapter 4 Estandarización y validación de covariables", " Chapter 4 Estandarización y validación de covariables De manera similar a cómo las variables del censo se sometieron a un proceso de validación, el conjunto de covariables se somete a un procedimiento similar. Esto implica asegurar la uniformidad en la longitud de los identificadores, como UGM, cantones, regiones, etc. Además, se realiza una validación para identificar valores faltantes (NAs) en el conjunto de datos. A continuación, se realiza un análisis descriptivo de los datos. "],["preparación-del-entorno-y-carga-de-bibliotecas.html", "4.1 Preparación del entorno y carga de bibliotecas", " 4.1 Preparación del entorno y carga de bibliotecas Este código es responsable de revisar y mejorar los datos que tenemos. Primero, borra cualquier cosa que tengamos en la memoria. Luego, carga algunas herramientas especiales que vamos a utilizar. Después, lee información sobre el censo y las áreas geográficas. ################# ### Libraries ### ################# # Load required libraries library(tidyverse) # For data manipulation and visualization library(data.table) # For efficient data manipulation library(openxlsx) # For reading Excel files library(magrittr) # For data handling operations # Clear the console cat(&quot;\\f&quot;) ## Reading census data. # Load the &#39;censo_viviendas.rds&#39; file containing census data censo1 &lt;- readRDS(&quot;Recursos/03_Input_Validation_Cov/Data/censo_viviendas.rds&quot;) ## Reading UGMS bases. # Load the &#39;ugm_merged.rds&#39; file containing UGMS base data Base_ugms &lt;- readRDS(&quot;Recursos/03_Input_Validation_Cov/Data/ugm_merged.rds&quot;) # Count distinct UGM_ID values in census data n_distinct(censo1$UGM_ID) ## [1] 48060 #48060 # Count distinct UGM_ID values in UGMS base data n_distinct(Base_ugms$UGM_ID) # Not all UGMs have houses ## [1] 50760 #50760 "],["valores-descriptivos-de-la-base-de-ugms.html", "4.2 Valores descriptivos de la base de UGMs", " 4.2 Valores descriptivos de la base de UGMs Comenzamos creando un marco de datos resumen que incluye los nombres de las columnas y sus tipos de datos correspondientes. Posteriormente, mejoramos este resumen agregando una columna que indica el tipo de dato de cada columna, lo que se logra mediante el uso de la función map_chr en los nombres de las columnas y sus datos correspondientes. # Create a summary dataframe with column names and their data types resumen &lt;- data.frame(Nombre_Columna = names(Base_ugms)) resumen %&lt;&gt;% mutate(tipo = map_chr(Nombre_Columna, function(x)class(Base_ugms[[x]]))) Variables numéricas # Calculate maximum values for numeric and integer columns max_values &lt;- Base_ugms %&gt;% summarise(across(where(is.numeric) | where(is.integer), max)) %&gt;% pivot_longer(everything(), names_to = &quot;Nombre_Columna&quot;, values_to = &quot;Valor_Maximo&quot;) # Calculate minimum values for numeric and integer columns min_values &lt;- Base_ugms %&gt;% summarise(across(where(is.numeric) | where(is.integer), min)) %&gt;% pivot_longer(everything(), names_to = &quot;Nombre_Columna&quot;, values_to = &quot;Valor_Minimo&quot;) # Calculate mean values for numeric and integer columns media_values &lt;- Base_ugms %&gt;% summarise(across(where(is.numeric) | where(is.integer), mean)) %&gt;% pivot_longer(everything(), names_to = &quot;Nombre_Columna&quot;, values_to = &quot;Valor_Media&quot;) # Calculate median values for numeric and integer columns mediana_values &lt;- Base_ugms %&gt;% summarise(across(where(is.numeric) | where(is.integer), median)) %&gt;% pivot_longer(everything(), names_to = &quot;Nombre_Columna&quot;, values_to = &quot;Valor_Mediana&quot;) # Calculate standard deviation values for numeric and integer columns SD_values &lt;- Base_ugms %&gt;% summarise(across(where(is.numeric) | where(is.integer), sd)) %&gt;% pivot_longer(everything(), names_to = &quot;Nombre_Columna&quot;, values_to = &quot;Valor_sd&quot;) # Calculate the number of missing values for numeric and integer columns nas_values &lt;- Base_ugms %&gt;% summarise(across(where(is.numeric) | where(is.integer), function(x)sum(is.na(x)))) %&gt;% pivot_longer(everything(), names_to = &quot;Nombre_Columna&quot;, values_to = &quot;Num_nas&quot;) Variables tipo carácter # Calculate maximum lengths of characters for character columns max_char &lt;- Base_ugms %&gt;% summarise(across(where(is.character), function(x)max(nchar(x)))) %&gt;% pivot_longer(everything(), names_to = &quot;Nombre_Columna&quot;, values_to = &quot;leng_max&quot;) # Calculate minimum lengths of characters for character columns min_char &lt;- Base_ugms %&gt;% summarise(across(where(is.character), function(x)min(nchar(x)))) %&gt;% pivot_longer(everything(), names_to = &quot;Nombre_Columna&quot;, values_to = &quot;leng_min&quot;) # Calculate the number of missing values for character columns nas_values_char &lt;- Base_ugms %&gt;% summarise(across(where(is.character) , function(x)sum(is.na(x)))) %&gt;% pivot_longer(everything(), names_to = &quot;Nombre_Columna&quot;, values_to = &quot;Num_nas_char&quot;) Organizando resultados en una base de datos # Combine all results into a single dataframe resumen2 &lt;- reduce( list( nas_values_char, min_char, max_char, nas_values, SD_values, mediana_values, media_values, min_values, max_values ), full_join, by = join_by(Nombre_Columna) ) %&gt;% full_join(x = resumen, y = ., by = join_by(Nombre_Columna)) resumen2 %&gt;% head(10) %&gt;% tba() Nombre_Columna tipo Num_nas_char leng_min leng_max Num_nas Valor_sd Valor_Mediana Valor_Media Valor_Minimo Valor_Maximo un_id integer NA NA NA 0 14653.29 25380.5 25380.5 1 50760 PROV_ID character 0 1 1 NA NA NA NA NA NA CANT_ID character 0 3 3 NA NA NA NA NA NA DIST_ID character 0 5 5 NA NA NA NA NA NA UGM_ID character 0 8 8 NA NA NA NA NA NA ugm_viviendas_totales_censo integer NA NA NA 1 NA NA NA NA NA ugm_viviendas_ocupadas_censo integer NA NA NA 1 NA NA NA NA NA ugm_viviendas_desocupadas_censo integer NA NA NA 1 NA NA NA NA NA ugm_peligrosidad numeric NA NA NA 1 NA NA NA NA NA ugm_problema_de_acceso numeric NA NA NA 1 NA NA NA NA NA Selección de variables de intrés Nombre_Columna &lt;- c( &quot;un_id&quot;, &quot;PROV_ID&quot;, &quot;CANT_ID&quot;, &quot;DIST_ID&quot;, &quot;UGM_ID&quot;, &quot;ugm_viviendas_totales_censo&quot;, &quot;ugm_viviendas_ocupadas_censo&quot;, &quot;ugm_viviendas_desocupadas_censo&quot;, &quot;ugm_peligrosidad&quot;, &quot;ugm_problema_de_acceso&quot;, &quot;ugm_riesgos_amenazas&quot;, &quot;ugm_cobertura_telecomunicaciones&quot;, &quot;ugm_area_m2&quot;, &quot;asent&quot;, &quot;ppp_CRI_v2&quot;, &quot;elev&quot;, &quot;indig&quot;, &quot;aprot&quot;, &quot;dist_permisos_de_construccion_2011_2022&quot;, &quot;dist_poblacion_proyeccion_ajustada_2022&quot;, &quot;dist_poblacion_rup&quot;, &quot;dist_poblacion_ccss_abril_2023&quot;, &quot;dist_matricula_educacion_primaria_2021&quot;, &quot;dist_matricula_educacion_secundaria_2021&quot;, &quot;dist_codigo_urbanidad&quot;, &quot;GHS_BUILT_S_E2020_GLOBE_R2023A_5367_CRI&quot;, &quot;urban_coverfraction&quot;, &quot;crops_coverfraction&quot;, &quot;ebais_tt&quot;, &quot;escu_tt&quot;, &quot;igl_tt&quot;, &quot;prov_nl_mean&quot;, &quot;cant_nl_mean&quot;, &quot;dist_nl_mean&quot;, &quot;wpop_sum&quot;, &quot;ugm_sin_info&quot;) Cambiando la naturaleza de las variables Tipo_actualizar &lt;- c( as.character, as.character, as.character, as.character, as.character, as.numeric, as.numeric, as.numeric, as.character, as.character, as.character, as.character, as.numeric, as.character, as.numeric, as.numeric, as.character, as.character, as.numeric, as.numeric, as.numeric, as.numeric, as.numeric, as.numeric, as.character, as.numeric, as.numeric, as.numeric, as.numeric, as.numeric, as.numeric, as.numeric, as.numeric, as.numeric, as.numeric, as.character) Actualizar los tipos de columna basados en Nombre_Columna y Tipo_actualizar. paso &lt;- map2(Nombre_Columna, Tipo_actualizar, function(nom, tipo) { Base_ugms[[nom]] &lt;&lt;- tipo(Base_ugms[[nom]]) cat(nom, &quot;\\n&quot;) }) ## un_id ## PROV_ID ## CANT_ID ## DIST_ID ## UGM_ID ## ugm_viviendas_totales_censo ## ugm_viviendas_ocupadas_censo ## ugm_viviendas_desocupadas_censo ## ugm_peligrosidad ## ugm_problema_de_acceso ## ugm_riesgos_amenazas ## ugm_cobertura_telecomunicaciones ## ugm_area_m2 ## asent ## ppp_CRI_v2 ## elev ## indig ## aprot ## dist_permisos_de_construccion_2011_2022 ## dist_poblacion_proyeccion_ajustada_2022 ## dist_poblacion_rup ## dist_poblacion_ccss_abril_2023 ## dist_matricula_educacion_primaria_2021 ## dist_matricula_educacion_secundaria_2021 ## dist_codigo_urbanidad ## GHS_BUILT_S_E2020_GLOBE_R2023A_5367_CRI ## urban_coverfraction ## crops_coverfraction ## ebais_tt ## escu_tt ## igl_tt ## prov_nl_mean ## cant_nl_mean ## dist_nl_mean ## wpop_sum ## ugm_sin_info Crear un data.frame resumen con los nombres de las columnas y sus tipos de datos. resumen &lt;- data.frame(Nombre_Columna = names(Base_ugms)) resumen %&lt;&gt;% mutate(tipo = map_chr(Nombre_Columna, function(x) class(Base_ugms[[x]]))) # Extract character columns tipo_char &lt;- resumen$Nombre_Columna[resumen$tipo == &quot;character&quot;] # Select and display character columns from Base_ugms Base_ugms[, tipo_char] %&gt;% head(10) %&gt;% tba() un_id PROV_ID CANT_ID DIST_ID UGM_ID ugm_peligrosidad ugm_problema_de_acceso ugm_riesgos_amenazas ugm_cobertura_telecomunicaciones asent indig aprot dist_codigo_urbanidad ugm_sin_info 1 1 101 10101 10101001 2 2 2 1 0 0 0 1 0 2 1 101 10101 10101002 2 2 2 1 0 0 0 1 0 3 1 101 10101 10101003 2 2 2 1 0 0 0 1 0 4 1 101 10101 10101004 2 2 2 1 0 0 0 1 0 5 1 101 10101 10101005 2 2 2 1 0 0 0 1 0 6 1 101 10101 10101006 2 2 2 1 0 0 0 1 0 7 1 101 10101 10101007 2 2 2 1 0 0 0 1 0 8 1 101 10101 10101008 2 2 2 1 0 0 0 1 0 9 1 101 10101 10101009 2 2 2 1 0 0 0 1 0 10 1 101 10101 10101010 2 2 2 1 0 0 0 1 0 4.2.1 Estandarización de variables y unión de conjuntos de datos. # Loop through character variables for (ii in tipo_char) { max_char &lt;- max(nchar(Base_ugms[[ii]]), na.rm = TRUE) Base_ugms[[ii]] &lt;- str_pad(string = Base_ugms[[ii]], width = max_char, pad = &quot;0&quot;) } UGM_censo &lt;- censo1 %&gt;% distinct(UGM_ID) # Join the UGM_censo and Base_ugms datasets Base_ugms_censo &lt;- inner_join(UGM_censo, Base_ugms) Base_ugms_censo[, tipo_char] %&gt;% head(10) %&gt;% tba() un_id PROV_ID CANT_ID DIST_ID UGM_ID ugm_peligrosidad ugm_problema_de_acceso ugm_riesgos_amenazas ugm_cobertura_telecomunicaciones asent indig aprot dist_codigo_urbanidad ugm_sin_info 00001 1 101 10101 10101001 2 2 2 1 0 0 0 1 0 00002 1 101 10101 10101002 2 2 2 1 0 0 0 1 0 00003 1 101 10101 10101003 2 2 2 1 0 0 0 1 0 00004 1 101 10101 10101004 2 2 2 1 0 0 0 1 0 00006 1 101 10101 10101006 2 2 2 1 0 0 0 1 0 00007 1 101 10101 10101007 2 2 2 1 0 0 0 1 0 00008 1 101 10101 10101008 2 2 2 1 0 0 0 1 0 00009 1 101 10101 10101009 2 2 2 1 0 0 0 1 0 00010 1 101 10101 10101010 2 2 2 1 0 0 0 1 0 00011 1 101 10101 10101011 2 2 2 1 0 0 0 1 0 Calcular el conteo de valores faltantes. # Calculate the counts of missing values for numeric variables nas_values &lt;- Base_ugms_censo %&gt;% summarise(across(where(is.numeric) | where(is.integer), function(x) sum(is.na(x)))) %&gt;% pivot_longer(everything(), names_to = &quot;Nombre_Columna&quot;, values_to = &quot;Num_nas&quot;) # Calculate the counts of missing values for character variables nas_values2 &lt;- Base_ugms_censo %&gt;% summarise(across(where(is.character), function(x) sum(is.na(x)))) %&gt;% pivot_longer(everything(), names_to = &quot;Nombre_Columna&quot;, values_to = &quot;Num_nas&quot;) Removiendo columnas adicionales de la base. Base_ugms_censo$dist_poblacion_rup &lt;- NULL Base_ugms_censo$dist_matricula_educacion_secundaria_2021 &lt;- NULL 4.2.2 Estandarizar las variables numéricas utilizando la escala de puntuación z (z-score). Base_ugms_censo &lt;- Base_ugms_censo %&gt;% mutate_if(is.numeric, function(x) as.numeric(scale(x))) Guardando la base estandarizada. saveRDS(Base_ugms_censo, &quot;Recursos/03_Input_Validation_Cov/Data/Base_ugms_estandarizada.rds&quot;) "],["modelo-binomial-de-unidad-para-viviendas-ocupadas.html", "Chapter 5 Modelo binomial de unidad para viviendas ocupadas", " Chapter 5 Modelo binomial de unidad para viviendas ocupadas En primera instancia, se definió un modelo estadístico para predecir la probabilidad de que una vivienda esté ocupada. Debido a un número significativo de viviendas en el censo que nunca respondieron a las llamadas de encuesta, se negaron a ser entrevistadas o simplemente no fueron localizables, fue necesario asignar una probabilidad de ocupación a estas viviendas. El modelo utilizado fue un modelo mixto bayesiano con una respuesta binomial y efectos aleatorios para provincias, cantones y distritos, como se detalla a continuación: \\(U_{ij}\\) es una variable dicotómica que indica el estado de ocupación de la \\(i\\)-ésima vivienda en la \\(j\\)-ésima área geográfica. \\(p_{ij}\\) es la probabilidad de que la \\(i\\)-ésima vivienda en la \\(j\\)-ésima área geográfica esté ocupada. \\(x_{ij}^\\prime \\beta\\) representa los efectos fijos considerados en el modelo que influyen en la probabilidad de ocupación. \\(z_{ij}^\\prime \\gamma\\) representa los efectos aleatorios que también influyen en la probabilidad de ocupación. Utilizamos la función logit para relacionar estas probabilidades y efectos, según la ecuación \\(\\text{logit}(p_{ij}) = x_{ij}^\\prime \\beta + z_{ij}^\\prime \\gamma\\). Para obtener resultados más precisos, se implementaron distribuciones a priori no informativas para los parámetros del modelo bayesiano. El resultado final proporciona una estimación del número de viviendas desocupadas en diferentes subdivisiones geográficas del país. "],["preparación-del-entorno-y-los-datos.html", "5.1 Preparación del entorno y los datos", " 5.1 Preparación del entorno y los datos En el siguiente bloque de código, iniciamos el proceso preparando nuestro entorno de R. Esto implica limpiar el espacio de trabajo para eliminar cualquier variable existente y cargar las bibliotecas necesarias para la manipulación de datos, visualización y análisis estadístico. Utilizamos bibliotecas como ‘tidyverse’ para la manipulación y visualización de datos, ‘data.table’ para la manipulación eficiente de datos, ‘openxlsx’ para leer archivos de Excel, ‘magrittr’ para la manipulación de datos utilizando operadores de tuberías, ‘lme4’ para ajustar modelos lineales mixtos, ‘rstan’ para el análisis bayesiano de datos utilizando Stan y ‘rstanarm’ para ajustar modelos de regresión bayesianos. Además, definimos la función ‘select’ de la paquetería ‘dplyr’ para la selección de columnas. Después de configurar el entorno, procedemos a leer los datos del censo. Leemos la información del censo desde el archivo ‘censo_viviendas.rds’ y extraemos columnas específicas relevantes para nuestro análisis, incluyendo ‘un_ID’ y ‘Filtros’. De manera similar, leemos los covariables UGM estandarizados del archivo ‘Base_ugms_estandarizada.rds’. Estos pasos iniciales sientan las bases para nuestro posterior análisis de datos y modelado. # Load required libraries library(tidyverse) # For data manipulation and visualization library(data.table) # For efficient data manipulation library(openxlsx) # For reading Excel files library(magrittr) # For data manipulation using pipe operators library(lme4) # For fitting linear mixed-effects models library(rstan) # For Bayesian data analysis using Stan library(rstanarm) # For fitting Bayesian regression models select &lt;- dplyr::select # Define the &#39;select&#39; function from dplyr package cat(&quot;\\f&quot;) # Clear the console ## Reading census data. # Read census data from the &#39;censo_viviendas.rds&#39; file and select specific columns censo_vivienda &lt;- readRDS(&quot;Recursos/04_Model_binomial/Data/censo_viviendas.rds&quot;) %&gt;% select(un_ID:Filtros) Covariables_UGM &lt;- readRDS(&quot;Recursos/04_Model_binomial/Data/Base_ugms_estandarizada.rds&quot;) # Read UGM covariates from the &#39;Base_ugms_estandarizada.rds&#39; file "],["definición-de-la-columna-desocupada-clasificación-del-estado-de-ocupación.html", "5.2 Definición de la columna ‘Desocupada’: Clasificación del estado de ocupación", " 5.2 Definición de la columna ‘Desocupada’: Clasificación del estado de ocupación Esta sección se centra en definir la columna ‘Desocupada’ en los datos del censo, la cual indica si una vivienda está desocupada. Los valores se determinan en función de condiciones específicas derivadas de las columnas ‘greenpoint2’ y ‘Filtros’, así como del número de individuos que viven en la vivienda. El proceso de clasificación es esencial para análisis y modelado posteriores. # Define the &#39;Desocupada&#39; column based on specific conditions censo_vivienda %&lt;&gt;% mutate( Desocupada = case_when( greenpoint2 == &quot;Censado con informacion n=0&quot; ~ 1, greenpoint2 == &quot;Censado con informacion n&gt;0&quot; ~ 0, greenpoint2 == &quot;Sin informacion pero n&gt;0&quot; ~ 0, Filtros == &quot;Censado en papel&quot; &amp; H01A_TOTAL_PERSONAS &gt; 0 ~ 0, Filtros == &quot;Censado en papel&quot; &amp; H01A_TOTAL_PERSONAS == 0 ~ 1, greenpoint2 == &quot;Sin informacion pero n&gt;=0&quot; ~ NA_real_ ) ) 5.2.1 Conteo de Combinaciones de Estado de Ocupación y Valores de ‘Greenpoint’ En esta sección, realizamos una agregación de datos para calcular el conteo de varias combinaciones de estado de ocupación y valores de ‘greenpoint2’. Al agrupar los datos en función de estas variables, podemos observar la distribución de patrones de ocupación de viviendas y las categorías de ‘greenpoint’ correspondientes. El resumen resultante, que incluye los conteos, se guarda en un archivo para referencia y análisis posterior. # Grouping and summarizing to get counts for different combinations conteos &lt;- censo_vivienda %&gt;% group_by(greenpoint2, Desocupada) %&gt;% summarise(total = n(), .groups = &quot;drop&quot;) conteos greenpoint2 Desocupada total Censado con informacion n=0 1 175921 Censado con informacion n&gt;0 0 776478 Papel n=0 1 1334 Papel n&gt;0 0 23344 Sin informacion pero n&gt;0 0 285810 Sin informacion pero n&gt;=0 NA 505032 # Grouping and summarizing data to create a binomial model base dataset base_conteo_viviendas &lt;- censo_vivienda %&gt;% group_by(UGM_ID) %&gt;% summarise( Desocupadas = sum(Desocupada, na.rm = TRUE), Ocupadas = sum(1 - Desocupada, na.rm = TRUE), n_vivienda = n() ) base_conteo_viviendas UGM_ID Desocupadas Ocupadas n_vivienda 10101001 0 1 1 10101002 0 2 2 10101003 5 1 6 10101004 1 2 3 10101006 1 0 1 10101007 1 0 1 10101008 2 0 2 10101009 8 1 9 10101010 1 0 1 10101011 1 1 2 Resumir las columnas numéricas en ‘base_conteo_viviendas’ y guardar los resultados readRDS(&quot;Recursos/04_Model_binomial/RecurseBooks/base_conteo2.rds&quot;) %&gt;% tba() Desocupadas Ocupadas n_vivienda 177255 1085632 1767919 Realizar una unión del conjunto de datos del modelo binomial con las covariables estandarizadas. base_conteo_viviendas &lt;- inner_join(base_conteo_viviendas, Covariables_UGM, by = &quot;UGM_ID&quot;) El código proporcionado incluye las siguientes opciones: options(mc.cores = parallel::detectCores()): Esta opción establece el número de núcleos utilizados para cálculos en paralelo en modelos Stan. La función parallel::detectCores() detecta automáticamente el número de núcleos de CPU disponibles en su máquina. Al configurar el número de núcleos, puede aprovechar el procesamiento en paralelo para acelerar el proceso de estimación del modelo Stan. rstan::rstan_options(auto_write = TRUE): Esta opción está relacionada con la escritura de modelos Stan compilados en el disco para fines de almacenamiento en caché. Cuando auto_write se establece en TRUE, indica que los modelos Stan compilados deben guardarse automáticamente en el disco para acelerar el proceso de compilación en ejecuciones futuras. Esto puede mejorar el tiempo de ejecución del modelo, especialmente si ejecuta el mismo modelo varias veces. Ambas opciones contribuyen a mejorar la eficiencia y la velocidad de ajuste de modelos Stan mediante el uso de procesamiento en paralelo y el almacenamiento en caché de modelos compilados. options(mc.cores = parallel::detectCores()) rstan::rstan_options(auto_write = TRUE) # Speed up running time modelo_binomial &lt;- stan_glmer( cbind(Desocupadas, Ocupadas) ~ 1 + (1 | PROV_ID) + (1 | CANT_ID) + (1 | DIST_ID) + ugm_peligrosidad + ugm_problema_de_acceso + ugm_riesgos_amenazas + ugm_cobertura_telecomunicaciones + dist_permisos_de_construccion_2011_2022 + dist_poblacion_proyeccion_ajustada_2022 + dist_poblacion_ccss_abril_2023 + dist_matricula_educacion_primaria_2021 + dist_codigo_urbanidad + GHS_BUILT_S_E2020_GLOBE_R2023A_5367_CRI + urban_coverfraction + crops_coverfraction + asent + ppp_CRI_v2 + elev + indig + aprot + ebais_tt + escu_tt + igl_tt + dist_nl_mean , data = base_conteo_viviendas, family = binomial(link = &quot;logit&quot;), iter = 15000, # total number of iterations per chain cores = 4, ) saveRDS(object = modelo_binomial, file = &quot;Recursos/04_Model_binomial/Data/Binomial_bayes_vivienda_desocupadas.rds&quot;) "],["consolidación-de-bases-de-datos-de-viviendas-del-censo.html", "Chapter 6 Consolidación de bases de datos de viviendas del CENSO", " Chapter 6 Consolidación de bases de datos de viviendas del CENSO # Clear the workspace by removing all variables rm(list = ls()) # Load required libraries library(tidyverse) # For data manipulation and visualization library(data.table) # For efficient data manipulation library(openxlsx) # For reading Excel files library(magrittr) # For data manipulation using pipe operators library(lme4) # For fitting linear mixed-effects models library(posterior) # For Bayesian data analysis library(rstanarm) # For fitting Bayesian regression models library(rstan) # For Bayesian data analysis using Stan cat(&quot;\\f&quot;) # Clear the console # Read census data from the &#39;censo_viviendas.rds&#39; file censo_vivienda &lt;- readRDS(&quot;Recursos/04_Model_binomial/Data/censo_viviendas.rds&quot;) # Read UGMS covariates from the &#39;Base_ugms_estandarizada.rds&#39; file Base_ugms &lt;- readRDS(&quot;Recursos/04_Model_binomial/Data/Base_ugms_estandarizada.rds&quot;) # Read binomial Bayesian model for unoccupied housing from the &#39;Binomial_bayes_vivienda_desocupadas.rds&#39; file modelo_binomial &lt;- readRDS(&quot;Recursos/04_Model_binomial/Data/Binomial_bayes_vivienda_desocupadas.rds&quot;) "],["definición-de-viviendas-ocupadas-y-desocupadas..html", "6.1 Definición de viviendas ocupadas y desocupadas.", " 6.1 Definición de viviendas ocupadas y desocupadas. censo_vivienda %&lt;&gt;% mutate(Desocupada = case_when( greenpoint2 == &quot;Censado con informacion n=0&quot; ~ 1, greenpoint2 == &quot;Censado con informacion n&gt;0&quot; ~ 0, greenpoint2 == &quot;Sin informacion pero n&gt;0&quot; ~ 0, Filtros == &quot;Censado en papel&quot; &amp; H01A_TOTAL_PERSONAS &gt; 0 ~ 0, Filtros == &quot;Censado en papel&quot; &amp; H01A_TOTAL_PERSONAS == 0 ~ 1, greenpoint2 == &quot;Sin informacion pero n&gt;=0&quot; ~ NA_real_ ) ) El código primero calcula el predictor lineal utilizando la función posterior_linpred para el modelo modelo_binomial, basándose en los datos de Base_ugms. Luego, transforma estas predicciones lineales para obtener las probabilidades predichas de viviendas desocupadas utilizando la función logística (plogis). # Waiting time of 5 to 10 minutes pred_linear &lt;- posterior_linpred(modelo_binomial, newdata = Base_ugms, draws = 1000) pred_unoccupied &lt;- plogis(pred_linear) El bloque de código siguiente (comentado) se encarga de guardar y cargar los valores predichos de viviendas desocupadas desde un archivo llamado “pred_unoccupied.rds”. Comprueba las dimensiones de los valores predichos y la Base_ugms, y resume las medias de los valores predichos, verificando si hay valores por debajo de 0 y por encima de 1. #saveRDS(pred_unoccupied, &quot;Recursos/04_Model_binomial/Data/pred_unoccupied.rds&quot;) pred_unoccupied &lt;- readRDS(&quot;Recursos/04_Model_binomial/Data/pred_unoccupied.rds&quot;) # Check dimensions of the predicted values and the base dim(pred_unoccupied) dim(Base_ugms) # Count the number of predicted values below 0 and above 1 sum(colMeans(pred_unoccupied) &lt; 0) sum(colMeans(pred_unoccupied) &gt; 1) # Summarize the means of predicted values summary(colMeans(pred_unoccupied)) Calcular los percentiles 2,5 y 97,5 de los valores previstos. q0.05 &lt;- apply(pred_unoccupied, MARGIN = 2, function(x) quantile(x, 0.05)) q0.95 &lt;- apply(pred_unoccupied, MARGIN = 2, function(x) quantile(x, 0.95)) # Calculate the standard deviation of predicted values sd_pred &lt;- apply(pred_unoccupied, MARGIN = 2, sd) summary(sd_pred) Crear un data.frame con intervalos de predicción intervalos &lt;- data.frame(UGM_ID = Base_ugms$UGM_ID, Pred_unoccupied = colMeans(pred_unoccupied), UpperLim_unoccupied = colMeans(pred_unoccupied) + 3 * sd_pred * q0.975, LowerLim_unoccupied = colMeans(pred_unoccupied) - 3 * sd_pred * q0.025 ) Unión entre censo_vivienda y la base de intervalos para la UGM_ID censo_vivienda %&lt;&gt;% inner_join(intervalos, by = &quot;UGM_ID&quot;) # Calculate new values for Desocupada and prediction intervals censo_vivienda %&lt;&gt;% mutate( Desocupada2 = case_when(is.na(Desocupada) ~ Pred_unoccupied, TRUE ~ Desocupada), LimInf_desocupadas = case_when(is.na(Desocupada) ~ LowerLim_unoccupied, TRUE ~ LimInf_desocupadas), LimSup_desocupadas = case_when(is.na(Desocupada) ~ UpperLim_unoccupied, TRUE ~ LimSup_desocupadas) ) "],["resumen-de-medidas-y-validación-de-resultados.html", "6.2 Resumen de medidas y validación de resultados", " 6.2 Resumen de medidas y validación de resultados En esta sección, calculamos varias medidas resumidas para validar los resultados de nuestro modelo. Calculamos la media y la suma de diferentes variables para las viviendas desocupadas originales, las viviendas desocupadas actualizadas y las viviendas desocupadas previstas. También se procede a calcular la estimación media, intervalos de confianza y porcentajes de viviendas desocupadas. # Calculate means and sums of different variables mean_original_desocupada &lt;- mean(censo_vivienda$Desocupada, na.rm = TRUE) mean_updated_desocupada &lt;- mean(censo_vivienda$Desocupada2) mean_predicted_desocupada &lt;- mean(censo_vivienda$Pred_unoccupied) sum_original_desocupada &lt;- sum(censo_vivienda$Desocupada, na.rm = TRUE) sum_updated_desocupada &lt;- sum(censo_vivienda$Desocupada2) sum_predicted_desocupada &lt;- sum(censo_vivienda$Pred_unoccupied) Calcular la estimación media, intervalos de confianza y porcentajes. result_summary &lt;- censo_vivienda %&gt;% mutate(MEInf_desocupadas = Desocupada2 - LimInf_desocupadas, MESup_desocupadas = LimSup_desocupadas - Desocupada2) %&gt;% summarise( total = sum(Desocupada2), Porcen = mean(Desocupada2) , LimInf_desocupadas = (Porcen - (mean(MEInf_desocupadas)/sqrt(n()))) * 100, LimSup_desocupadas = (Porcen + (mean(MESup_desocupadas)/sqrt(n()))) * 100, Porcen = Porcen * 100 ) total Porcen LimInf_desocupadas LimSup_desocupadas 220936.2 12.497 12.4969 12.497 Agrupar por PROV_ID y calcular MEInf_desocupadas y MESup_desocupadas prov_summary &lt;- censo_vivienda %&gt;% group_by(PROV_ID) %&gt;% mutate( MEInf_desocupadas = Desocupada2 - LimInf_desocupadas, MESup_desocupadas = LimSup_desocupadas - Desocupada2 ) %&gt;% summarise( total = sum(Desocupada2), Porcen = mean(Desocupada2), LimInf_desocupadas = (Porcen - (mean(MEInf_desocupadas) / sqrt(n()))) * 100, LimSup_desocupadas = (Porcen + (mean(MESup_desocupadas) / sqrt(n()))) * 100, Porcen = Porcen * 100, Leng_IC = LimSup_desocupadas - LimInf_desocupadas ) PROV_ID total Porcen LimInf_desocupadas LimSup_desocupadas Leng_IC 1 45529.82 8.5835 8.5835 8.5835 0.0001 2 41160.36 11.1431 11.1430 11.1431 0.0001 3 17470.38 9.4604 9.4604 9.4605 0.0001 4 13329.65 7.6866 7.6866 7.6867 0.0001 5 32031.88 21.4326 21.4321 21.4333 0.0012 6 45351.21 23.4420 23.4418 23.4423 0.0005 7 26062.89 15.5966 15.5965 15.5967 0.0002 Agrupar por CANT_ID y calcular MEInf_desocupadas y MESup_desocupadas cant_summary &lt;- censo_vivienda %&gt;% group_by(CANT_ID) %&gt;% mutate( MEInf_desocupadas = Desocupada2 - LimInf_desocupadas, MESup_desocupadas = LimSup_desocupadas - Desocupada2 ) %&gt;% summarise( total = sum(Desocupada2), Porcen = mean(Desocupada2), LimInf_desocupadas = (Porcen - (mean(MEInf_desocupadas) / sqrt(n()))) * 100, LimSup_desocupadas = (Porcen + (mean(MESup_desocupadas) / sqrt(n()))) * 100, Porcen = Porcen * 100, Leng_IC = LimSup_desocupadas - LimInf_desocupadas ) CANT_ID total Porcen LimInf_desocupadas LimSup_desocupadas Leng_IC 101 7171.275 7.3095 7.3095 7.3095 1e-04 102 1330.895 5.5770 5.5770 5.5771 1e-04 103 3419.079 4.9146 4.9145 4.9147 1e-04 104 1902.457 12.7750 12.7749 12.7752 3e-04 105 1791.999 24.9686 24.9677 24.9697 2e-03 106 1778.785 8.0209 8.0207 8.0211 3e-04 107 1844.608 14.1588 14.1586 14.1591 5e-04 108 2024.655 4.8765 4.8764 4.8765 1e-04 109 1212.172 5.3084 5.3083 5.3085 2e-04 110 1620.085 6.3151 6.3151 6.3152 2e-04 Agrupar por DIST_ID y calcular MEInf_desocupadas y MESup_desocupadas dist_summary &lt;- censo_vivienda %&gt;% group_by(DIST_ID) %&gt;% mutate( MEInf_desocupadas = Desocupada2 - LimInf_desocupadas, MESup_desocupadas = LimSup_desocupadas - Desocupada2 ) %&gt;% summarise( total = sum(Desocupada2), Porcen = mean(Desocupada2), LimInf_desocupadas = (Porcen - (mean(MEInf_desocupadas) / sqrt(n()))) * 100, LimSup_desocupadas = (Porcen + (mean(MESup_desocupadas) / sqrt(n()))) * 100, Porcen = Porcen * 100, Leng_IC = LimSup_desocupadas - LimInf_desocupadas ) DIST_ID total Porcen LimInf_desocupadas LimSup_desocupadas Leng_IC 10101 379.6071 26.1078 26.1054 26.1108 0.0054 10102 416.0615 8.6535 8.6532 8.6540 0.0008 10103 490.3833 7.6959 7.6957 7.6962 0.0004 10104 801.3848 15.3434 15.3428 15.3441 0.0013 10105 902.0885 13.3130 13.3128 13.3132 0.0004 10106 430.8623 6.2308 6.2308 6.2309 0.0001 10107 226.6559 2.0111 2.0111 2.0112 0.0000 10108 555.6962 13.3420 13.3417 13.3425 0.0009 10109 1110.6140 5.2551 5.2550 5.2552 0.0002 10110 1078.2147 6.6812 6.6812 6.6813 0.0001 Guardar censo_vivienda modificado sin columna Pred_unoccupied censo_vivienda_modified &lt;- censo_vivienda %&gt;% dplyr::select(-Pred_unoccupied) saveRDS(censo_vivienda_modified, file = &quot;Recursos/04_Model_binomial/Data/01_censo_vivienda_desocupadas.rds&quot;) "],["estimación-del-número-de-personas-por-hogar.html", "Chapter 7 Estimación del número de personas por hogar", " Chapter 7 Estimación del número de personas por hogar ### Libraries ### # Load required libraries library(tidyverse) # For data manipulation and visualization library(data.table) # For efficient data manipulation library(openxlsx) # For reading Excel files library(magrittr) # For data manipulation using pipe operators library(lme4) # For fitting linear mixed-effects models library(rstan) # For Bayesian data analysis using Stan library(rstanarm) # For fitting Bayesian regression models cat(&quot;\\f&quot;) # Clear the console "],["lectura-de-los-datos-del-censo..html", "7.1 Lectura de los datos del censo.", " 7.1 Lectura de los datos del censo. # Read census data from the &#39;censo_viviendas.rds&#39; file censo_vivienda &lt;- readRDS(&quot;Recursos/05_Model_for_people/Data/censo_viviendas.rds&quot;) # Read UGM covariates from the &#39;Base_ugms_estandarizada.rds&#39; file Base_ugms &lt;- readRDS(&quot;Recursos/05_Model_for_people/Data/Base_ugms_estandarizada.rds&quot;) "],["preparando-datos-para-el-modelo-1.html", "7.2 Preparando datos para el Modelo 1", " 7.2 Preparando datos para el Modelo 1 # Calculate the mean of total persons per UGM, excluding specific conditions base_ugm_estima_todas &lt;- censo_vivienda %&gt;% filter( !greenpoint2 %in% c(&quot;Sin informacion pero n&gt;0&quot;, &quot;Sin informacion pero n&gt;=0&quot;)) %&gt;% group_by(UGM_ID) %&gt;% summarise(tot_personas = sum(H01A_TOTAL_PERSONAS, na.rm = TRUE) ) # Check the number of rows and missing values nrow(base_ugm_estima_todas) sum(is.na(base_ugm_estima_todas$tot_personas)) # Join the UGM mean total persons with UGM covariates base_ugm_estima_todas &lt;- inner_join(base_ugm_estima_todas, Base_ugms, by = &quot;UGM_ID&quot;) # Check the number of rows after joining nrow(base_ugm_estima_todas) Ajustar un modelo Stan GLM para estimar las medias de la población total # Estimated time of 2 to 3 hours modelo_todas &lt;- glm( tot_personas ~ 1 + PROV_ID + CANT_ID + DIST_ID + dist_codigo_urbanidad + ugm_peligrosidad + ugm_problema_de_acceso + ugm_riesgos_amenazas + ugm_cobertura_telecomunicaciones + dist_permisos_de_construccion_2011_2022 + dist_poblacion_proyeccion_ajustada_2022 + dist_poblacion_ccss_abril_2023 + dist_matricula_educacion_primaria_2021 + GHS_BUILT_S_E2020_GLOBE_R2023A_5367_CRI + urban_coverfraction + crops_coverfraction + asent + ppp_CRI_v2 + elev + indig + aprot + ebais_tt + escu_tt + igl_tt + dist_nl_mean , data = base_ugm_estima_todas, family = poisson(link = &quot;log&quot;) ) # Save the fitted model to a file saveRDS(modelo_todas, &quot;Recursos/05_Model_for_people/Data/fit_poisson_todas.rds&quot;) "],["preparando-datos-para-el-modelo-2.html", "7.3 Preparando datos para el Modelo 2", " 7.3 Preparando datos para el Modelo 2 # Calculate the mean of total persons per UGM for occupied households base_ugm_estima_ocupadas &lt;- censo_vivienda %&gt;% filter( greenpoint2 %in% c(&quot;Censado con informacion n&gt;0&quot;, &quot;Papel n&gt;0&quot;)) %&gt;% group_by(UGM_ID) %&gt;% summarise(tot_personas = sum(H01A_TOTAL_PERSONAS, na.rm = TRUE) ) # Check the number of rows and missing values nrow(base_ugm_estima_ocupadas) sum(is.na(base_ugm_estima_ocupadas$tot_personas)) # Join the UGM mean total persons for occupied households with UGM covariates base_ugm_estima_ocupadas &lt;- inner_join(base_ugm_estima_ocupadas, Base_ugms, by = &quot;UGM_ID&quot;) # Check the number of rows after joining nrow(base_ugm_estima_ocupadas) Instalar un modelo Stan GLM para viviendas ocupadas. modelo_ocupadas &lt;- glm( tot_personas ~ 1 + PROV_ID + CANT_ID + DIST_ID + dist_codigo_urbanidad + ugm_peligrosidad + ugm_problema_de_acceso + ugm_riesgos_amenazas + ugm_cobertura_telecomunicaciones + dist_permisos_de_construccion_2011_2022 + dist_poblacion_proyeccion_ajustada_2022 + dist_poblacion_ccss_abril_2023 + dist_matricula_educacion_primaria_2021 + dist_codigo_urbanidad + GHS_BUILT_S_E2020_GLOBE_R2023A_5367_CRI + urban_coverfraction + crops_coverfraction + asent + ppp_CRI_v2 + elev + indig + aprot + ebais_tt + escu_tt + igl_tt + dist_nl_mean , data = base_ugm_estima_ocupadas, family = poisson(link = &quot;log&quot;) ) # Save the fitted model for occupied households to a file saveRDS(modelo_ocupadas, &quot;Recursos/05_Model_for_people/Data/fit_poisson_ocupadas.rds&quot;) "],["consolidar-el-número-de-personas-por-hogar.html", "Chapter 8 Consolidar el número de personas por hogar", " Chapter 8 Consolidar el número de personas por hogar ################# ### Libraries ### ################# library(tidyverse) library(data.table) library(openxlsx) library(magrittr) library(lme4) # For fitting linear mixed-effects models library(rstan) # For Bayesian data analysis using Stan library(rstanarm) # For fitting Bayesian regression models library(merTools) cat(&quot;\\f&quot;) Leer datos y modelos censales. censo_vivienda &lt;- readRDS(&quot;Recursos/05_Model_for_people/Data/01_censo_vivienda_desocupadas.rds&quot;) Base_ugms &lt;- readRDS(&quot;Recursos/05_Model_for_people/Data/Base_ugms_estandarizada.rds&quot;) modelo_todas &lt;- readRDS(&quot;Recursos/05_Model_for_people/Data/fit_poisson_todas.rds&quot;) modelo_ocupadas &lt;- readRDS(&quot;Recursos/05_Model_for_people/Data/fit_poisson_ocupadas.rds&quot;) Hacer predicciones utilizando los modelos. pred_todas &lt;- predict(modelo_todas, newdata = Base_ugms, type = &quot;response&quot;, se.fit = TRUE) saveRDS(pred_todas,file = &quot;Recursos/05_Model_for_people/Data/pred_todas.rds&quot;) pred_todas &lt;- readRDS(file = &quot;Recursos/05_Model_for_people/Data/pred_todas.rds&quot;) Base_ugms$pred_todas &lt;- pred_todas$fit Base_ugms$pred_todas_se &lt;- pred_todas$se.fit hist(Base_ugms$pred_todas) pred_ocupadas &lt;- predict(modelo_ocupadas, newdata = Base_ugms, type = &quot;response&quot;, se.fit = TRUE) saveRDS(pred_ocupadas,file = &quot;Recursos/05_Model_for_people/Data/pred_ocupadas.rds&quot;) pred_ocupadas &lt;- readRDS(file = &quot;Recursos/05_Model_for_people/Data/pred_ocupadas.rds&quot;) Base_ugms$pred_ocupadas &lt;- pred_ocupadas$fit Base_ugms$pred_ocupadas_se &lt;- pred_ocupadas$se.fit hist(Base_ugms$pred_ocupadas) summary(Base_ugms$pred_todas) summary(Base_ugms$pred_ocupadas) Fusionar información del censo con predicciones. censo_temp &lt;- censo_vivienda %&gt;% full_join(Base_ugms) %&gt;% group_by(UGM_ID) %&gt;% mutate( pred_conteos = case_when( greenpoint2 == &quot;Sin informacion pero n&gt;0&quot; ~ pred_ocupadas, greenpoint2 == &quot;Sin informacion pero n&gt;=0&quot; ~ pred_todas , TRUE ~ H01A_TOTAL_PERSONAS ), MEInf_pred_conteos = case_when( greenpoint2 == &quot;Sin informacion pero n&gt;0&quot; ~ 1.96*pred_ocupadas_se, greenpoint2 == &quot;Sin informacion pero n&gt;=0&quot; ~ 1.96*pred_todas_se , TRUE ~ 0 ), MESup_pred_conteos = case_when( greenpoint2 == &quot;Sin informacion pero n&gt;0&quot; ~ 1.96*pred_ocupadas_se, greenpoint2 == &quot;Sin informacion pero n&gt;=0&quot; ~ 1.96*pred_todas_se , TRUE ~ 0 ) ) Calcular la suma de las predicciones. sum(censo_temp$pred_conteos) # Summary of estimates per UGM censo_temp %&gt;% group_by(UGM_ID) %&gt;% summarise(Min_ugm = min(pred_conteos), Max_ugm = max(pred_conteos)) %&gt;% View() # Summary of estimates filtered by greenpoint2 censo_temp %&gt;% filter(greenpoint2 == &quot;Sin informacion pero n&gt;=0&quot; ) %&gt;% group_by(UGM_ID) %&gt;% summarise(Min_ugm = min(pred_conteos), Max_ugm = max(pred_conteos))%&gt;% View() Guardar información consolidada en un archivo. saveRDS(censo_temp, file = &quot;Recursos/05_Model_for_people/Data/02_censo_vivienda_personas.rds&quot;) "],["modelo-multinomial-para-estimar-personas-por-rango-de-edad-y-sexo.html", "Chapter 9 Modelo multinomial para estimar personas por rango de edad y sexo", " Chapter 9 Modelo multinomial para estimar personas por rango de edad y sexo En el paso final, modelamos la estructura demográfica de las Unidades Geográficas Pequeñas (UGMs) a nivel de provincia. Esta estructura consta de 40 subgrupos basados en la combinación de género y grupos de edad. Para estimar la demografía de hogares no observados, utilizamos la predicción condicional basada en los resultados del paso anterior. Dada la naturaleza del fenómeno en estudio, se considera adecuada una distribución multinomial para el recuento de individuos en los 40 grupos. Aquí tienes una explicación del modelo: \\(G_i\\) sigue una distribución Multinomial \\(Multinomial(p_{G_i})\\). Las log-odds de \\(p_{G_i}\\) están modeladas por \\(x_i^T\\beta\\). En este contexto, \\(G_i\\) representa el recuento de cada uno de los cuarenta grupos demográficos. \\(p_{G_i}\\) es un vector de tamaño 40 que contiene las probabilidades de que una persona clasificada en cada grupo resida en un hogar. Limpieza del entorno de R El código elimina todos los objetos del entorno de R actual, asegurando un punto de partida limpio para las operaciones posteriores. # Loading necessary libraries for data analysis. library(tidyverse) # Data manipulation and visualization library(data.table) # Fast data manipulation library(openxlsx) # Reading Excel files library(magrittr) # Pipe operator library(lme4) # For fitting linear mixed-effects models library(nnet) # For fitting neural networks cat(&quot;\\f&quot;) # Clears console output Leyendo datos # Reading the preprocessed census data file containing information about households. censo_vivienda &lt;- readRDS(&quot;Recursos/06_Model_Multinomial/Data/02_censo_vivienda_personas.rds&quot;) # Filtering the census data to retain relevant columns for age and gender analysis. censo_vivienda_age_gender &lt;- censo_vivienda %&gt;% filter( !greenpoint2 %in% c(&quot;Sin informacion pero n&gt;0&quot;, &quot;Sin informacion pero n&gt;=0&quot;)) %&gt;% dplyr::select(PROV_ID, HOMBRES_GRUPO1_sum:MUJERES_GRUPO20_sum) Preparación de datos: El código crea un nuevo conjunto de datos, censo_vivienda_edad_sexo, filtrando entradas específicas de censo_vivienda. Se seleccionan columnas relacionadas con grupos de edad y género y provincias. Luego, este conjunto de datos filtrado se agrega a nivel de PROV_ID utilizando la función summarise_if. # Summarizing the age and gender data by grouping it based on province (PROV_ID). censo_personas &lt;- censo_vivienda_age_gender %&gt;% group_by(PROV_ID) %&gt;% summarise_if(is.numeric, sum) Modelo Multinomial: Se crea un modelo multinomial utilizando la función multinom. Este modelo predice la distribución de grupos de edad y género dentro de los hogares según la provincia (PROV_ID). El modelo se almacena en la variable model. # Fitting a multinomial model to estimate the distribution of age and gender within households, # using province as the predictor. model &lt;- multinom( censo_personas[,-1] %&gt;% as.matrix() ~ censo_personas$PROV_ID) ## # weights: 320 (273 variable) ## initial value 9098525.262706 ## iter 10 value 8725423.620363 ## iter 20 value 8724936.747528 ## iter 30 value 8724362.718376 ## iter 40 value 8723575.429512 ## iter 50 value 8719973.199033 ## iter 60 value 8714415.379026 ## iter 70 value 8692534.417677 ## iter 80 value 8664249.357504 ## iter 90 value 8663007.095699 ## iter 100 value 8662293.319310 ## final value 8662293.319310 ## stopped after 100 iterations Predicción del Modelo: La función predict se utiliza para predecir las probabilidades de distribución para el modelo multinomial. Los resultados de la predicción no se muestran aquí, pero se pueden obtener utilizando la función predict. # Predicting the distribution probabilities using the fitted model. predict(model,type = &quot;probs&quot;) Guardar el Modelo El modelo multinomial entrenado se guarda como un archivo RDS (“Recursos/06_Model_Multinomial/Data/Multinomial_model.rds”) utilizando la función saveRDS. # Saving the fitted multinomial model to a file. saveRDS(model, &quot;Recursos/06_Model_Multinomial/Data/Multinomial_model.rds&quot;) "],["creando-la-base-censal-con-predicciones-del-modelo-multinomial.html", "Chapter 10 Creando la base censal con predicciones del modelo multinomial", " Chapter 10 Creando la base censal con predicciones del modelo multinomial ### Cleaning R environment ### rm(list = ls()) ### Libraries ### library(tidyverse) # Set of packages for data manipulation and visualization library(data.table) # For efficient data operations library(openxlsx) # Excel file manipulation library(magrittr) # Pipe operations (%&gt;%) library(lme4) # Linear mixed-effects models cat(&quot;\\f&quot;) # Page break in R console Reading the census data. censo_vivienda &lt;- readRDS(&quot;Recursos/06_Model_Multinomial/Data/02_censo_vivienda_personas.rds&quot;) # Reading the previously created multinomial model. model &lt;- readRDS(&quot;Recursos/06_Model_Multinomial/Data/Multinomial_model.rds&quot;) # Calculate probabilities for each outcome category using the model. probabilidad &lt;- predict(model, type = &quot;probs&quot;) %&gt;% as.data.frame() %&gt;% select_all(~paste0(.,&quot;_prob&quot;)) %&gt;% mutate(PROV_ID = as.character(1:7)) # Create a copy of the census data to work with. censo_vivienda_pred &lt;- censo_vivienda # Calculate the sum of predicted counts. sum(censo_vivienda_pred$pred_conteos) # Identify column names corresponding to age groups. var_grupo &lt;- grep(x = names(censo_vivienda_pred), pattern = &quot;*_GRUPO\\\\d{,2}_sum$&quot;, value = TRUE) "],["resultados-por-provincias.html", "10.1 Resultados por Provincias", " 10.1 Resultados por Provincias PROV_ID = 1 # Filter census data for PROV_ID = 1 and specific greenpoint2 categories. PROV_1 &lt;- censo_vivienda_pred %&gt;% filter(PROV_ID == &quot;1&quot; , greenpoint2 %in% c(&quot;Sin informacion pero n&gt;=0&quot;, &quot;Sin informacion pero n&gt;0&quot;)) # Calculate predicted counts for each age group in PROV_1. PROV_1[, var_grupo] &lt;- matrix(PROV_1$pred_conteos, nrow = nrow(PROV_1)) %*% matrix(as.numeric(probabilidad[1, paste0(var_grupo, &quot;_prob&quot;)]), ncol = 40) # Calculate lower bound of predicted counts for each age group in PROV_1. PROV_1[,paste0(var_grupo, &quot;_MEInf&quot;) ] &lt;- matrix(PROV_1$MEInf_pred_conteos,nrow = nrow(PROV_1)) %*% matrix(as.numeric(probabilidad[1,paste0(var_grupo, &quot;_prob&quot;) ]),ncol = 40 ) # Calculate upper bound of predicted counts for each age group in PROV_1. PROV_1[,paste0(var_grupo, &quot;_MESup&quot;) ] &lt;- matrix(PROV_1$MESup_pred_conteos,nrow = nrow(PROV_1)) %*% matrix(as.numeric(probabilidad[1,paste0(var_grupo, &quot;_prob&quot;) ]),ncol = 40 ) # Calculate the sum of predicted counts for each age group in PROV_1. rowSums(PROV_1[,var_grupo]) # Calculate the sum of predicted counts in PROV_1. sum(PROV_1[,var_grupo]) sum(PROV_1$pred_conteos) # Calculate the sum of lower bounds of predicted counts in PROV_1. sum(PROV_1[,paste0(var_grupo, &quot;_MEInf&quot;) ]) sum(PROV_1$MEInf_pred_conteos) # Calculate the sum of upper bounds of predicted counts in PROV_1. sum(PROV_1[,paste0(var_grupo, &quot;_MESup&quot;) ]) sum(PROV_1$MESup_pred_conteos) PROV_ID = 2 # Filter census data for PROV_ID = 2 and specific greenpoint2 categories. PROV_2 &lt;- censo_vivienda_pred %&gt;% filter(PROV_ID == &quot;2&quot; , greenpoint2 %in% c(&quot;Sin informacion pero n&gt;=0&quot;, &quot;Sin informacion pero n&gt;0&quot;)) # Calculate predicted counts for each age group in PROV_2. PROV_2[,var_grupo] &lt;- matrix(PROV_2$pred_conteos,nrow = nrow(PROV_2)) %*% matrix(as.numeric(probabilidad[2,paste0(var_grupo, &quot;_prob&quot;) ]),ncol = 40 ) # Calculate lower bound of predicted counts for each age group in PROV_2. PROV_2[,paste0(var_grupo, &quot;_MEInf&quot;) ] &lt;- matrix(PROV_2$MEInf_pred_conteos,nrow = nrow(PROV_2)) %*% matrix(as.numeric(probabilidad[2,paste0(var_grupo, &quot;_prob&quot;) ]),ncol = 40 ) # Calculate upper bound of predicted counts for each age group in PROV_2. PROV_2[,paste0(var_grupo, &quot;_MESup&quot;) ] &lt;- matrix(PROV_2$MESup_pred_conteos,nrow = nrow(PROV_2)) %*% matrix(as.numeric(probabilidad[2,paste0(var_grupo, &quot;_prob&quot;) ]),ncol = 40 ) # Calculate the sum of predicted counts for each age group in PROV_2. rowSums(PROV_2[,var_grupo]) # Calculate the sum of predicted counts in PROV_2. sum(PROV_2[,var_grupo]) sum(PROV_2$pred_conteos) # Calculate the sum of lower bounds of predicted counts in PROV_2. sum(PROV_2[,paste0(var_grupo, &quot;_MEInf&quot;) ]) sum(PROV_2$MEInf_pred_conteos) # Calculate the sum of upper bounds of predicted counts in PROV_2. sum(PROV_2[,paste0(var_grupo, &quot;_MESup&quot;) ]) sum(PROV_2$MESup_pred_conteos) PROV_ID = 3 PROV_3 &lt;- censo_vivienda_pred %&gt;% filter( PROV_ID == &quot;3&quot; , greenpoint2 %in% c(&quot;Sin informacion pero n&gt;=0&quot;, &quot;Sin informacion pero n&gt;0&quot;) ) # Display summary statistics of the selected age group data in PROV_3. summary(PROV_3[, var_grupo]) # Calculate predicted counts for each age group in PROV_3. PROV_3[, var_grupo] &lt;- matrix(PROV_3$pred_conteos, nrow = nrow(PROV_3)) %*% matrix(as.numeric(probabilidad[3, paste0(var_grupo, &quot;_prob&quot;)]), ncol = 40) # Calculate lower bound of predicted counts for each age group in PROV_3. PROV_3[, paste0(var_grupo, &quot;_MEInf&quot;)] &lt;- matrix(PROV_3$MEInf_pred_conteos, nrow = nrow(PROV_3)) %*% matrix(as.numeric(probabilidad[3, paste0(var_grupo, &quot;_prob&quot;)]), ncol = 40) # Calculate upper bound of predicted counts for each age group in PROV_3. PROV_3[, paste0(var_grupo, &quot;_MESup&quot;)] &lt;- matrix(PROV_3$MESup_pred_conteos, nrow = nrow(PROV_3)) %*% matrix(as.numeric(probabilidad[3, paste0(var_grupo, &quot;_prob&quot;)]), ncol = 40) # Calculate the sum of predicted counts for each age group in PROV_3. rowSums(PROV_3[,var_grupo]) # Calculate the sum of predicted counts in PROV_3. sum(PROV_3[,var_grupo]) sum(PROV_3$pred_conteos) # Calculate the sum of lower bounds of predicted counts in PROV_3. sum(PROV_3[,paste0(var_grupo, &quot;_MEInf&quot;) ]) sum(PROV_3$MEInf_pred_conteos) # Calculate the sum of upper bounds of predicted counts in PROV_3. sum(PROV_3[,paste0(var_grupo, &quot;_MESup&quot;) ]) sum(PROV_3$MESup_pred_conteos) PROV_ID = 4 PROV_4 &lt;- censo_vivienda_pred %&gt;% filter( PROV_ID == &quot;4&quot; , greenpoint2 %in% c(&quot;Sin informacion pero n&gt;=0&quot;, &quot;Sin informacion pero n&gt;0&quot;) ) summary(PROV_4[,var_grupo]) # Calculate predicted counts for each age group in PROV_4. PROV_4[, var_grupo] &lt;- matrix(PROV_4$pred_conteos, nrow = nrow(PROV_4)) %*% matrix(as.numeric(probabilidad[4, paste0(var_grupo, &quot;_prob&quot;)]), ncol = 40) # Calculate lower bound of predicted counts for each age group in PROV_4. PROV_4[, paste0(var_grupo, &quot;_MEInf&quot;)] &lt;- matrix(PROV_4$MEInf_pred_conteos, nrow = nrow(PROV_4)) %*% matrix(as.numeric(probabilidad[4, paste0(var_grupo, &quot;_prob&quot;)]), ncol = 40) # Calculate upper bound of predicted counts for each age group in PROV_4. PROV_4[, paste0(var_grupo, &quot;_MESup&quot;)] &lt;- matrix(PROV_4$MESup_pred_conteos, nrow = nrow(PROV_4)) %*% matrix(as.numeric(probabilidad[4, paste0(var_grupo, &quot;_prob&quot;)]), ncol = 40) # Calculate the sum of predicted counts for each age group in PROV_4. rowSums(PROV_4[,var_grupo]) # Calculate the sum of predicted counts in PROV_4. sum(PROV_4[,var_grupo]) sum(PROV_4$pred_conteos) # Calculate the sum of lower bounds of predicted counts in PROV_4. sum(PROV_4[,paste0(var_grupo, &quot;_MEInf&quot;) ]) sum(PROV_4$MEInf_pred_conteos) # Calculate the sum of upper bounds of predicted counts in PROV_4. sum(PROV_4[,paste0(var_grupo, &quot;_MESup&quot;) ]) sum(PROV_4$MESup_pred_conteos) PROV_ID = 5 PROV_5 &lt;- censo_vivienda_pred %&gt;% filter(PROV_ID == &quot;5&quot; , greenpoint2 %in% c(&quot;Sin informacion pero n&gt;=0&quot;, &quot;Sin informacion pero n&gt;0&quot;)) summary(PROV_5[,var_grupo]) # Calculate predicted counts for each age group in PROV_5. PROV_5[,var_grupo] &lt;- matrix(PROV_5$pred_conteos,nrow = nrow(PROV_5)) %*% matrix(as.numeric(probabilidad[5,paste0(var_grupo, &quot;_prob&quot;) ]),ncol = 40 ) # Calculate lower bound of predicted counts for each age group in PROV_5. PROV_5[,paste0(var_grupo, &quot;_MEInf&quot;)] &lt;- matrix(PROV_5$MEInf_pred_conteos,nrow = nrow(PROV_5)) %*% matrix(as.numeric(probabilidad[5,paste0(var_grupo, &quot;_prob&quot;) ]),ncol = 40 ) # Calculate upper bound of predicted counts for each age group in PROV_5. PROV_5[,paste0(var_grupo, &quot;_MESup&quot;)] &lt;- matrix(PROV_5$MESup_pred_conteos,nrow = nrow(PROV_5)) %*% matrix(as.numeric(probabilidad[5,paste0(var_grupo, &quot;_prob&quot;) ]),ncol = 40 ) # Calculate the sum of predicted counts for each age group in PROV_5. rowSums(PROV_5[,var_grupo]) # Calculate the sum of predicted counts in PROV_5. sum(PROV_5[,var_grupo]) sum(PROV_5$pred_conteos) # Calculate the sum of lower bounds of predicted counts in PROV_5. sum(PROV_5[,paste0(var_grupo, &quot;_MEInf&quot;) ]) sum(PROV_5$MEInf_pred_conteos) # Calculate the sum of upper bounds of predicted counts in PROV_5. sum(PROV_5[,paste0(var_grupo, &quot;_MESup&quot;) ]) sum(PROV_5$MESup_pred_conteos) PROV_ID = 6 PROV_6 &lt;- censo_vivienda_pred %&gt;% filter( PROV_ID == &quot;6&quot; , greenpoint2 %in% c(&quot;Sin informacion pero n&gt;=0&quot;, &quot;Sin informacion pero n&gt;0&quot;) ) summary(PROV_6[,var_grupo]) # Calculate predicted counts for each age group in PROV_6. PROV_6[, var_grupo] &lt;- matrix(PROV_6$pred_conteos, nrow = nrow(PROV_6)) %*% matrix(as.numeric(probabilidad[6, paste0(var_grupo, &quot;_prob&quot;)]), ncol = 40) # Calculate lower bound of predicted counts for each age group in PROV_6. PROV_6[, paste0(var_grupo, &quot;_MEInf&quot;)] &lt;- matrix(PROV_6$MEInf_pred_conteos, nrow = nrow(PROV_6)) %*% matrix(as.numeric(probabilidad[6, paste0(var_grupo, &quot;_prob&quot;)]), ncol = 40) # Calculate upper bound of predicted counts for each age group in PROV_6. PROV_6[, paste0(var_grupo, &quot;_MESup&quot;)] &lt;- matrix(PROV_6$MESup_pred_conteos, nrow = nrow(PROV_6)) %*% matrix(as.numeric(probabilidad[6, paste0(var_grupo, &quot;_prob&quot;)]), ncol = 40) # Calculate the sum of predicted counts for each age group in PROV_6. rowSums(PROV_6[,var_grupo]) # Calculate the sum of predicted counts in PROV_6. sum(PROV_6[,var_grupo]) sum(PROV_6$pred_conteos) # Calculate the sum of lower bounds of predicted counts in PROV_6. sum(PROV_6[,paste0(var_grupo, &quot;_MEInf&quot;) ]) sum(PROV_6$MEInf_pred_conteos) # Calculate the sum of upper bounds of predicted counts in PROV_6. sum(PROV_6[,paste0(var_grupo, &quot;_MESup&quot;) ]) sum(PROV_6$MESup_pred_conteos) PROV_ID = 7 PROV_7 &lt;- censo_vivienda_pred %&gt;% filter( PROV_ID == &quot;7&quot; , greenpoint2 %in% c(&quot;Sin informacion pero n&gt;=0&quot;, &quot;Sin informacion pero n&gt;0&quot;) ) summary(PROV_7[, var_grupo]) # Calculate predicted counts for each age group in PROV_7. PROV_7[, var_grupo] &lt;- matrix(PROV_7$pred_conteos, nrow = nrow(PROV_7)) %*% matrix(as.numeric(probabilidad[7, paste0(var_grupo, &quot;_prob&quot;)]), ncol = 40) # Calculate lower bound of predicted counts for each age group in PROV_7. PROV_7[, paste0(var_grupo, &quot;_MEInf&quot;)] &lt;- matrix(PROV_7$MEInf_pred_conteos, nrow = nrow(PROV_7)) %*% matrix(as.numeric(probabilidad[7, paste0(var_grupo, &quot;_prob&quot;)]), ncol = 40) # Calculate upper bound of predicted counts for each age group in PROV_7. PROV_7[, paste0(var_grupo, &quot;_MESup&quot;)] &lt;- matrix(PROV_7$MESup_pred_conteos, nrow = nrow(PROV_7)) %*% matrix(as.numeric(probabilidad[7, paste0(var_grupo, &quot;_prob&quot;)]), ncol = 40) # Calculate the sum of predicted counts for each age group in PROV_7. rowSums(PROV_7[, var_grupo]) # Calculate the sum of predicted counts in PROV_7. sum(PROV_7[, var_grupo]) sum(PROV_7$pred_conteos) # Calculate the sum of lower bounds of predicted counts in PROV_7. sum(PROV_7[, paste0(var_grupo, &quot;_MEInf&quot;)]) sum(PROV_7$MEInf_pred_conteos) # Calculate the sum of upper bounds of predicted counts in PROV_7. sum(PROV_7[, paste0(var_grupo, &quot;_MESup&quot;)]) sum(PROV_7$MESup_pred_conteos) Combinar los resultados de las provincias con información faltante. prov_sin_informacion &lt;- list( PROV_1, PROV_2, PROV_3, PROV_4, PROV_5, PROV_6, PROV_7) %&gt;% bind_rows() Algunas validaciones # Filter and gather data for all provinces with missing information PROV_todas &lt;- censo_vivienda_pred %&gt;% filter(greenpoint2 %in% c(&quot;Sin informacion pero n&gt;=0&quot;, &quot;Sin informacion pero n&gt;0&quot;)) # Calculate row sums and total sum of predicted counts for provinces with missing information rowSums(prov_sin_informacion[, var_grupo]) sum(prov_sin_informacion[, var_grupo]) sum(PROV_todas$pred_conteos) # Filter data for provinces with complete census information PROV_censada &lt;- censo_vivienda_pred %&gt;% filter(!greenpoint2 %in% c(&quot;Sin informacion pero n&gt;=0&quot;, &quot;Sin informacion pero n&gt;0&quot;)) Inicializar columnas para los límites inferior y superior de los recuentos previstos # in provinces with complete census PROV_censada[,paste0(var_grupo, &quot;_MEInf&quot;)] &lt;- 0 PROV_censada[,paste0(var_grupo, &quot;_MESup&quot;)] &lt;- 0 # Combine data frames of provinces with complete and missing information for each age group censo_vivienda_grupo_edad &lt;- bind_rows(PROV_censada, prov_sin_informacion) %&gt;% dplyr::select(un_ID, var_grupo, paste0(var_grupo, &quot;_MEInf&quot;), paste0(var_grupo, &quot;_MESup&quot;)) # Inner join the census data with the grouped age data and save the result readRDS(&quot;Recursos/06_Model_Multinomial/Data/04_censo_vivienda_personas.rds&quot;) %&gt;% inner_join(censo_vivienda_grupo_edad) %&gt;% saveRDS(&quot;Recursos/06_Model_Multinomial/Data/05_censo_vivienda_personas_grupo_edad.rds&quot;) "],["estimaciones-agregadas.html", "Chapter 11 Estimaciones Agregadas", " Chapter 11 Estimaciones Agregadas En esta sección, ilustramos la metodología empleada para obtener estimaciones en varios niveles de agregación, utilizando un conjunto de funciones personalizadas adaptadas a este conjunto de datos específico. Estas funciones facilitan el proceso de generar predicciones y visualizaciones, lo que nos permite analizar de manera efectiva las estimaciones de población. ### Libraries ### library(tidyverse) library(data.table) library(openxlsx) library(magrittr) library(lme4) library(rstan) library(rstanarm) source(&quot;Recursos/07_Resultados/Rcodes/01_Agregados.R&quot;) cat(&quot;\\f&quot;) - plot_densidad: Esta función grafica la densidad de una distribución normal con una media y desviación estándar especificadas. Además, resalta un intervalo específico de la distribución con un área sombreada y segmentos en el gráfico. Pred_desocupado: Esta función realiza cálculos y visualizaciones relacionados con los datos de desempleo en un censo. Pred_totPob: Esta función realiza cálculos y visualizaciones relacionados con los datos de población total en un censo. plot_piramide_pob: Genera un gráfico de pirámide de población con barras e intervalos de confianza. piramide_pob: Calcula y visualiza la pirámide de población a partir de los datos del censo. Reading the census data. censo_vivienda &lt;- readRDS(&quot;Recursos/07_Resultados/Data/05_censo_vivienda_personas_grupo_edad.rds&quot;) "],["prediction-of-the-unoccupied-household-rate.html", "11.1 Prediction of the unoccupied household rate", " 11.1 Prediction of the unoccupied household rate p1 &lt;- Pred_desocupado(censo_vivienda, agrega = NULL, Plot = TRUE, filtro = NULL) tba(p1) total Porcen LimInf LimSup Len_IC SE 170596 9.6495 7.8008 15.6923 7.8915 2.0131 Pred_desocupado(censo_vivienda, agrega = &quot;PROV_ID&quot;) %&gt;% tba() PROV_ID total Porcen LimInf LimSup Len_IC SE 1 32511.23 6.1292 5.3021 9.9408 4.6388 1.1834 2 32237.42 8.7274 6.9849 15.4285 8.4436 2.1540 3 12311.19 6.6667 5.8987 10.1143 4.2157 1.0754 4 10280.48 5.9283 4.7734 11.5613 6.7879 1.7316 5 26994.96 18.0624 12.7344 29.9794 17.2451 4.3993 6 36611.60 18.9245 15.2168 27.3844 12.1677 3.1040 7 19649.10 11.7585 9.7813 18.6686 8.8873 2.2672 Pred_desocupado(censo_vivienda, agrega = &quot;CANT_ID&quot;) %&gt;% head(20) %&gt;% tba() CANT_ID total Porcen LimInf LimSup Len_IC SE 101 4704.3753 4.7950 3.8687 9.8229 5.9542 1.5189 102 904.1052 3.7886 3.3167 6.7276 3.4109 0.8701 103 2326.4401 3.3440 2.7587 6.1325 3.3738 0.8607 104 1302.8111 8.7484 7.9692 11.9333 3.9640 1.0112 105 1529.1408 21.3061 18.9280 27.2467 8.3187 2.1221 106 1303.6682 5.8785 4.8028 11.5253 6.7225 1.7149 107 1329.3520 10.2038 9.0813 14.9483 5.8670 1.4967 108 1191.2768 2.8692 2.4607 5.4149 2.9541 0.7536 109 906.0511 3.9678 3.2436 8.0984 4.8548 1.2385 110 1071.5921 4.1771 3.4247 8.4890 5.0643 1.2919 111 629.5658 2.8960 2.6462 4.4006 1.7544 0.4476 112 1188.2365 13.0146 11.3643 17.6408 6.2765 1.6011 113 1338.6913 6.3086 5.8192 8.6923 2.8730 0.7329 114 842.5751 3.6877 3.3801 5.6110 2.2309 0.5691 115 860.8183 4.3823 3.7200 8.1193 4.3993 1.1223 116 793.8269 21.9047 19.4176 28.8232 9.4056 2.3994 117 1028.0808 26.3206 21.9920 34.4197 12.4277 3.1703 118 671.6741 2.7472 2.0860 7.0503 4.9643 1.2664 119 7588.2603 12.7034 11.5004 16.7497 5.2493 1.3391 120 1000.6907 18.8206 16.7473 24.5034 7.7561 1.9786 Pred_desocupado(censo_vivienda, agrega = &quot;DIST_ID&quot;) %&gt;% head(20) %&gt;% tba() DIST_ID total Porcen LimInf LimSup Len_IC SE 10101 259.9300 17.8769 14.8636 26.9333 12.0698 3.0790 10102 242.6324 5.0464 3.5641 13.1547 9.5906 2.4466 10103 325.8134 5.1132 4.0814 10.8335 6.7521 1.7225 10104 525.2972 10.0574 8.1812 17.8866 9.7055 2.4759 10105 622.1515 9.1817 8.2921 13.0957 4.8036 1.2254 10106 260.6938 3.7700 3.5110 5.3212 1.8102 0.4618 10107 162.3146 1.4402 1.2844 2.5274 1.2430 0.3171 10108 357.2789 8.5781 7.3951 13.9366 6.5415 1.6688 10109 855.4386 4.0477 2.5018 13.3719 10.8702 2.7730 10110 626.1736 3.8801 3.3093 7.2516 3.9423 1.0057 10111 466.6511 3.3683 2.8908 6.2913 3.4005 0.8675 10201 193.1655 4.6201 4.3063 6.4739 2.1676 0.5530 10202 200.4354 2.3603 1.8712 5.6881 3.8169 0.9737 10203 510.5042 4.5617 4.0439 7.6111 3.5672 0.9100 10301 194.1877 1.6909 1.3653 3.8786 2.5133 0.6411 10302 313.4239 2.8655 2.5148 5.0408 2.5260 0.6444 10303 178.4447 3.0514 2.7513 4.8938 2.1425 0.5466 10304 160.4965 3.4126 3.0166 5.7444 2.7278 0.6959 10305 122.9297 3.7331 3.3143 6.2113 2.8970 0.7390 10306 135.8658 9.8668 9.0079 13.5051 4.4971 1.1472 p1 &lt;- Pred_desocupado(censo_vivienda, agrega = &quot;DIST_ID&quot;, Plot = TRUE, filtro = &quot;10101&quot;) tba(p1) DIST_ID total Porcen LimInf LimSup Len_IC SE 10101 259.93 17.8769 14.8636 26.9333 12.0698 3.079 "],["predicción-del-total-de-personas.html", "11.2 Predicción del total de personas", " 11.2 Predicción del total de personas ## National level result p1 &lt;- Pred_totPob(censo_vivienda, agrega = NULL, Plot = TRUE) tba(p1) total SE LimInf LimSup Len_IC 4946930 142207.6 4713709 5180150 466441.1 ## Provincial level result Pred_totPob(censo_vivienda, agrega = &quot;PROV_ID&quot;, Plot = FALSE) %&gt;% tba() PROV_ID total SE LimInf LimSup Len_IC 1 1530576.8 41244.79 1462935.4 1598218.3 135282.90 2 1081285.5 34928.27 1024003.2 1138567.9 114564.74 3 556988.1 12840.36 535929.9 578046.3 42116.39 4 488545.0 19039.91 457319.5 519770.5 62450.91 5 376403.3 11948.63 356807.5 395999.0 39191.51 6 462538.7 12163.66 442590.3 482487.1 39896.81 7 450592.3 10042.02 434123.4 467061.2 32937.82 p1 &lt;- Pred_totPob(censo_vivienda, agrega = &quot;PROV_ID&quot;, filtro = &quot;1&quot;, Plot = TRUE) tba(p1) PROV_ID total SE LimInf LimSup Len_IC 1 1530577 41244.79 1462935 1598218 135282.9 ## Canton level result Pred_totPob(censo_vivienda, agrega = &quot;CANT_ID&quot;, Plot = FALSE, filtro = NULL) %&gt;% head(10) %&gt;% tba() CANT_ID total SE LimInf LimSup Len_IC 101 281842.11 6236.7553 271613.83 292070.39 20456.5574 102 68507.40 1866.2504 65446.75 71568.05 6121.3012 103 228526.32 6772.9845 217418.63 239634.02 22215.3891 104 39408.22 869.5673 37982.13 40834.31 2852.1809 105 17538.35 304.1923 17039.48 18037.23 997.7509 106 64000.23 2099.7100 60556.71 67443.75 6887.0487 107 33842.91 912.9030 32345.75 35340.08 2994.3218 108 123340.97 3504.8231 117593.06 129088.88 11495.8199 109 66265.86 3008.8440 61331.36 71200.37 9869.0085 110 83597.98 2654.4832 79244.62 87951.33 8706.7048 ## District level result p1 &lt;- Pred_totPob(censo_vivienda, agrega = &quot;DIST_ID&quot;, Plot = TRUE, filtro = &quot;10110&quot;) tba(p1) DIST_ID total SE LimInf LimSup Len_IC 10110 48209.95 701.333 47059.76 49360.13 2300.372 "],["predicción-del-total-de-personas-por-rango-de-edad-y-sexo.html", "11.3 Predicción del total de personas por rango de edad y sexo", " 11.3 Predicción del total de personas por rango de edad y sexo piramide_pob( censo = censo_vivienda, Plot = FALSE, agrega = NULL, filtro = NULL ) %&gt;% tba() grupo total SE LimInf LimSup Len_IC HOMBRES_GRUPO1 132715.613 3538.5296 126912.424 138518.801 11606.3771 HOMBRES_GRUPO2 167537.132 4578.1619 160028.946 175045.318 15016.3711 HOMBRES_GRUPO3 182328.109 5216.9996 173772.230 190883.989 17111.7587 HOMBRES_GRUPO4 180165.851 5189.0721 171655.772 188675.929 17020.1564 HOMBRES_GRUPO5 191782.430 5695.3272 182442.094 201122.767 18680.6731 HOMBRES_GRUPO6 196681.972 5950.4734 186923.195 206440.748 19517.5529 HOMBRES_GRUPO7 197411.070 5831.3041 187847.732 206974.409 19126.6774 HOMBRES_GRUPO8 191008.448 5694.5553 181669.377 200347.519 18678.1415 HOMBRES_GRUPO9 156522.833 4345.9776 149395.430 163650.236 14254.8066 HOMBRES_GRUPO10 136569.728 3926.0488 130131.008 143008.448 12877.4402 HOMBRES_GRUPO11 135995.420 3837.4780 129701.956 142288.884 12586.9279 HOMBRES_GRUPO12 131888.989 3722.7379 125783.699 137994.279 12210.5804 HOMBRES_GRUPO13 124940.164 3636.1568 118976.867 130903.461 11926.5942 HOMBRES_GRUPO14 106462.067 3190.2168 101230.112 111694.023 10463.9111 HOMBRES_GRUPO15 72514.563 2030.2378 69184.973 75844.153 6659.1799 HOMBRES_GRUPO16 46304.067 1199.7564 44336.467 48271.668 3935.2009 HOMBRES_GRUPO17 29636.441 776.7665 28362.544 30910.338 2547.7942 HOMBRES_GRUPO18 17569.383 501.4791 16746.957 18391.809 1644.8513 HOMBRES_GRUPO19 10052.158 364.0234 9455.160 10649.157 1193.9969 HOMBRES_GRUPO20 5693.759 252.7038 5279.325 6108.193 828.8686 MUJERES_GRUPO1 133932.122 3859.4112 127602.687 140261.556 12658.8686 MUJERES_GRUPO2 159219.926 4341.0499 152100.604 166339.247 14238.6437 MUJERES_GRUPO3 168190.704 4687.5265 160503.161 175878.247 15375.0868 MUJERES_GRUPO4 170967.814 4858.5844 162999.736 178935.892 15936.1569 MUJERES_GRUPO5 191028.640 5721.8012 181644.886 200412.394 18767.5078 MUJERES_GRUPO6 196498.415 5882.7348 186850.730 206146.100 19295.3702 MUJERES_GRUPO7 202199.447 5917.3901 192494.927 211903.966 19409.0394 MUJERES_GRUPO8 202895.997 5970.9001 193103.721 212688.273 19584.5523 MUJERES_GRUPO9 180427.823 5269.6683 171785.567 189070.079 17284.5122 MUJERES_GRUPO10 148689.282 4216.8396 141773.665 155604.899 13831.2340 MUJERES_GRUPO11 151500.141 4202.3081 144608.356 158391.927 13783.5705 MUJERES_GRUPO12 150358.720 4204.6298 143463.127 157254.313 13791.1857 MUJERES_GRUPO13 141620.661 4066.5684 134951.489 148289.833 13338.3444 MUJERES_GRUPO14 119528.269 3458.0552 113857.058 125199.479 11342.4210 MUJERES_GRUPO15 85609.538 2485.4344 81533.426 89685.650 8152.2249 MUJERES_GRUPO16 54136.719 1433.8634 51785.183 56488.255 4703.0721 MUJERES_GRUPO17 35611.090 934.7107 34078.165 37144.016 3065.8511 MUJERES_GRUPO18 21527.179 582.6755 20571.591 22482.766 1911.1756 MUJERES_GRUPO19 12157.783 374.7621 11543.173 12772.393 1229.2197 MUJERES_GRUPO20 6679.249 260.7253 6251.659 7106.838 855.1791 p1 &lt;- piramide_pob( censo = censo_vivienda, Plot = TRUE, agrega = NULL, filtro = NULL) p1 &lt;- piramide_pob( censo = censo_vivienda, Plot = FALSE, agrega = &quot;PROV_ID&quot;, filtro = NULL ) p1 &lt;- piramide_pob( censo = censo_vivienda, Plot = TRUE, agrega = &quot;PROV_ID&quot;, filtro = &quot;1&quot; ) p1&lt;- piramide_pob( censo = censo_vivienda, Plot = TRUE, agrega = &quot;PROV_ID&quot;, filtro = &quot;2&quot; ) p1 &lt;- piramide_pob( censo = censo_vivienda, Plot = TRUE, agrega = &quot;CANT_ID&quot;, filtro = &quot;101&quot; ) p1&lt;- piramide_pob( censo = censo_vivienda, Plot = TRUE, agrega = &quot;CANT_ID&quot;, filtro = &quot;102&quot; ) "]]
